#summary The Entrelacs Abstract Machine

= Introduction =

The second major component of an Entrelacs System beside the ArrowsSpace is the _Entrelacs Abstract Machine_. It's a software machine which evals programs directly stored as arrows constructs.

Programs are defined according to the [EntrelacsLanguage Entrelacs Language] (EL). This language is designed so that there is no difference between, source code, CST (Concrete Syntax Tree), and AST (Abstract Syntax Tree). The objective is to simplify meta-programming and persistent reflexivity.

The machine state itself consists in an arrow construct which may be read and modified by the running program. A programs may consequently handle all the underlying machine state components like:
  * environments,
  * continuations,
  * closures,
  * evaluated expression
  * etc.

It obviously implies that *the machine state itself takes part of the language definition*.

== Sources and credits ==
The _Entrelacs Machine_ described hereafter is largely inspired by the 
[http://users.info.unicaen.fr/~karczma/TEACH/Doc/compi_cont.pdf "_CaEK_" abstract machine of Flanagan et al. (1993)].

So the EL language is equivalent to the "Core Scheme in A-normal form" (_A(CS)_) very basic (no type) functional language introduced in this paper.

The only thing to keep in mind is that programs and machine states are directly hold by arrows structures.

Textual source code is reserved for communication purpose. The current prototype should be able to assimilate arrow in the form of s-expression or URI (see [EntrelacsServer] API).

== Extensions to the very strict A(CS)_ language==

The EL language brings modifications to the _A(CS)_ language. They are tagged with #e# hereafter.

These extensions include:
   * The possibility to eval few CS expression which are not in A-normal form -like (t s) expressions-. They are handled by rewriting them on the fly into their A-normal equivalent.
   * Arrow casting and escaping. Any arrow may be seen as a variable symbol, or an expression, or a literal.
   * Unbound variables are left as is. Evaluating "hello" returns "hello" if not a bound variable.
   * Application on something other than a closure is left as is. ("hello" "world") returns ("hello" "world") if "hello" is not bound to a closure and "world" not bound.
   * the "@M" keyword is bound to the current machine state
   * a run keyword allows to replace the current machine state

== Restrictions ==

Functions are one-variable only.

= The Language =
{{{
x ::= any entrelacs arrow (Eve, tags, blobs)
a ::= x | (a a) // any arrow

// literals
v ::=  x // entrelacs are resolved if bound, otherwise left as is
       | ("escape" a) // escape any arrow (prevent expression evaluation) #e#
       | ("get" a) // escape and cast any arrow as a variable + resolve it before evaluating the expression  #e#

// trivial expression
t ::=  	v
 	| ("lambda" (v s)) // lambda expression

// serious expression in A-normal form
s ::=	("let" ((v t) s)) // binding
  	| ("let" ((v (t t)) s)) // application in binding
  	| (t t) // application

// EL expression
e ::=   s
  	| ("let" ((x (t s)) s)) // serious exp in application in binding #e#
  	| (t s) // serious exp in application #e#

// EL program
p ::= e
}}}

Missing: operators and system continuations.

= The Machine =

== Trivial expressions ==

{{{
<arrow> ::= any arrow
<entrelacs> ::= any entrelacs arrow
<escape> ::= ("escape" <arrow>) #e#
<get> ::= ("get" <arrow>) #e#
<lambda-expression> ::= ("lambda" (<arrow> <expression>))
<trivial> ::= <entrelacs> | <lambda-expression>
                       | <escape> | <get> #e#
}}}

== Programs ==
{{{
<application> ::= (<trivial> <trivial>)
<serious-application> ::= (<trivial> <serious>) #e#
<binding> ::= ("let" ((<variable> <trivial>) <serious>))
<application-binding> ::= ("let" ((<variable> <application>) <serious>))
<serious-application-binding> ::= ("let" ((<variable> <serious-application>) <serious>)) #e#
<serious> ::= <binding> | <application-binding> | <binding>
              | <serious-application-binding> | <serious-binding> #e#
<expression> ::= <trivial> | <serious>
<program> ::= <expression>
}}}

== Environment and closure ==

{{{
<variable> ::= <arrow>
<value> ::= <arrow>

<environment> ::= Eve | ((<variable> <value>) <environment>)
/* ((<variable> <value>) ((<variable> <value>)... ((<variable> <value>) Eve) ... )) */

<closure> ::= ((<variable> <expression>) <environment>)
}}}

== The Continuation chain, aka stack ==

{{{
<continuation-chain> ::=
      Eve
    | (<"continuation" (<hook> <context>)) #e#
    | (<frame> <continuation-chain>)
/* (<frame> (<frame> ... (<frame> Eve) ... )) */
<frame> ::= (<variable> (<expression> <environment>))
}}}

TODO: is not a frame actually a closure?

== The Machine State ==

{{{
<machine-state> := (<program> (<environment> <continuation-chain>))
}}}

== System functions and variables ==
Uncompleted list
 * head
 * tail
 * childrenOf
 * root
 * unroot
 * isRooted
 * run : replace the current machine state with the provided one.
 * "@M" : current machine state 

== Machine dynamics ==

=== _resolve_ function ===

{{{
  Arrow resolve(Arrow trivial, Arrow environment)
}}}

Pseudo pattern matching algo:
{{{
let resolve(t, e) =
   match t with:
     | ("lambda" (x s)) -> ((x s) e) /* closure */
     | ("get" x) -> resolveVariable(x, e) #e#
     | ("escape" a) -> a #e#
     | "@M" -> current machine state #e#
     | x -> resolveVariableIfBound(x, e)

let resolveVariableIfBound(x, e) =
   match e with:
     | Eve -> x /* Miss: An unbound variable is left as is*/
     | ((x value) head) -> value /* Hit */
     | (tail head) -> resolveVariable(x, head) /* recursion */
}}}

=== _isTrivial_ function ===
Pseudo-C algo:
{{{
   Boolean isTrivial(Arrow expression) = {
     return
        isEntrelacs(exp)
     || tail(exp) == "lambda"
     || tail(exp) == "escape" #e#
     || tail(exp) == "get" #e#
   }
}}}

=== _eval_ function ===

Pseudo-C algo:
{{{
Arrow eval(program) {
  M = (program (Eve Eve))
  M = transition(M);
  while (head(head(M)) != Eve) {
    M = transition(M)
  }
  p = tail(M)
  e = tail(head(M))
  return resolve(p, e)
}

}}}

=== _transition_ function ===

Pseudo-C algo:
{{{
#define _(a,b) = arrow(a,b)

Arrow transition(Arrow M) {
  // match M to (p (e k))
  p = tail(M)
  e = tail(head(M))
  k = head(head(M))

  if (isTrivial(p)) { // Trivial expression
     // p = v
     if (k == Eve) return // stop, program result = resolve(p, e)
     if (tail(k) == continuation) { //special system continuation #e#
        // k = (continuation (<hook> <context>))
        hook = castAsPointer(tail(head(k)))
        context = castAsPointer(head(head(k))
        M = hook(M, context)
     } else {
       // k = ((x (ss ee)) kk)
       w = resolve(p, e)
       kk = head(k)
       f = tail(k)
       x = tail(f)
       ss = tail(head(f))
       ee = head(head(f))
       M = _(ss, _(_(_(x, w), ee), kk)) // unstack continuation, postponed let solved
     }
  } else if (tail(p)) == let) { //let expression family
     // p = (let ((x v) s))
     v = head(tail(head(p))
     x = tail(tail(head(p))

     if (tail(x) == "get") { x = resolve(x); } #e#

     if (isTrivial(v)) { // Trivial let rule
       // p = (let ((x t) s))
       t = v
       w = resolve(t, e)
       s = head(head(p))
       M = _(s, _(_(_(x, w), e), k))
     } else /* !isTrivial(v) */ { // Non trivial let rules
       // p = (let ((x (t0 s1) s))
       t0 = tail(v)
       v1 = head(v)
       if (!isTrivial(v1)) { // Very serious let rule #e#
         pp = _(let, _(_(p, s1), _(let, _(_(x, _(t0, _(get, p))), s)
         M = _(pp, _(e, k))
       } else /* isTrivial(v1)) */ { // Serious let rule
         // p = (let ((x t) s)) where t = (t0 t1)
         t1 = v1
         t0 = tail(t)
         t1 = head(t)
         w = resolve(t1, e)
         C = resolve(t0, e)
         if (tail(C) == "operator") { // Operator call
           // C = (operator (hook context))
           hook = getPointer(tail(head(C)))
           context = getPointer(head(head(C))
           r = hook(w, context)
           M = _(s, _(_(_(x, r), e), k))
         } else if (tail(C) == "continuation") { // System continuation call
           // C = (continuation (hook context))
           hook = getPointer(tail(head(C)))
           context = getPointer(head(head(C))
 	   M = _(t, _(e, _(_(x, _(s, e)), k))) // polish the machine state
           M = hook(M, context) // continuation operator does a transition by itself

         } else { // closure case
           // C = ((y ss) ee)
           ee = head(C)
	   y = tail(tail(C))
           ss = head(tail(C))
 	   M = _(ss, _(_(_(y, w), ee), _(_(x, _(s, e)), k))) // stacks up a continuation
         }
       }
     }
  } else if (!isTrivial(s = head(P))) { // Not trivial application #e#
     // p = (t s)
     pp = _(let, _(_(p, s), _(t, _(get, p))
     M = _(pp, _(e, k))

  } else { // Trivial application rule
     // p = (t0 t1)
     // Stacking not needed
     t0 = tail(p)
     C = resolve(t0, e)
     if (tail(C) == continuation) { // System continuation call
       // C = (continuation (hook context))
       hook = getPointer(tail(head(C)))
       context = getPointer(head(head(C))
       M = hook(M, context)  // continuation operator does a transition by itself
       return
     }

     t1 = head(p)
     w = resolve(t1, e)
     if (tail(C) == operator) { // Operator call
       // C = (operator (hook context))
       hook = getPointer(tail(head(C)))
       context = getPointer(head(head(C))
       r = hook(w, context)
       M = _(r, _(e, k))
     } else { // closure case
       // C = ((x ss) ee)
       x = tail(tail(C))
       ss = head(tail(C))
       ee = head(C)
       M = _(ss, _(_(_(x, w), ee), k))
     }
  }
}
}}}

Note: the actual machine also features a lambdax construct. Works like lambda but parameter is not evaluated in application. Allows to make "let" like construct. TODO: convergence lambdax/system-cc
