#summary The Entrelacs Abstract Machine

= Introduction =

The Entrelacs Abstract Machine evals programs made up of arrows.

Its language is as well:
  * a functional language
  * a stack based language
  * a Call By Continuation style language
  * a query language Ã  la SQL
  * a fully reflexive language

= Machine State =

The Machine state is defined by a single arrow _M_ which is made up of:
  * _current_ : a "current" arrow
  * _program_ : to-be-evaluated program
  * _stack_ : a stack (as an arrow)
  * _continuation_ : a continuation

{{{
 M = (current ((stack program) continuation)))
}}}


= Real reflexivity =

Within a working Entrelacs systems, programs are directly stored as arrow structures (serialized text representation is only supported for communication purpose).

All in all, there is no difference between a piece of source code, a Concrete Syntax Tree (CST) and even an Abstract Syntax Tree (AST) in Entrelacs! Moreover, the current machine state (M) can be fully acceded and modified by programs. Programs can browse (introspection) and modify (intercession) such arrows in order to modify themselves for real!  Programs can not only modify themselves but also store their changes.

= The language =
== loading "current arrow" ==
{{{
 42             tag "42"
 @AEFA00FA      previously retrieved arrow
 "foo"          tag "foo"
 (some program) closure
 t              current arrow tail
 h              current arrow head
 &              ( stack head ; current arrow ) link
 M              current state machine
  ->  Mhh       current continuation
  ->  Mhth      current program
  ->  Mhtt      current stack
}}}

== Testing ==
{{{
 ~         ( stack head ; current arrow ) pair -> arrow if stored only, otherwhise Eve
 ==        current arrow set to Eve if not equal to stack head
 _         current arrow set to Eve if not rooted
}}}

== arrows stacking ==
{{{
 < add current arrow to stack
 > unstack to current arrow
}}}

== continuation chaining ==
{{{
 : add current arrow to continuation chain (supposed to be closure but not necessary) 
 / cut = replace current continuation with next continuation
 ; unchain next continuation without make it current
 ???? swap current continuation with next continuation (TBC)
}}}

== branching ==
{{{
 ? if current arrow is Eve then cut
}}}

== continuation mapping ==
{{{
 i incomings of current arrow
 o outgoings ...
}}}

== syntaxic sugars ==
{{{
 'foo (then white space) <==> "foo"
 $foo (then white space) <==> 'foo o_?h
 , <==> < (stack)
 . <==> Mhh (current continuation)
}}}

= Examples (in the form of unparsed strings) =
==  Basic browse ==
{{{
 "'foo" ==> "foo" arrow
 "'foo + 'bar &" ==> 'foo->'bar arrow
 "'foo o" ==> each arrow outgoing from 'foo'
 "'foo oh" ==> the head of each known arrow outgoing from 'foo'
 "'foo i_?t" ==> each x verifying (x->'foo') rooted
 "'foo i_?<t<'bar ==?>>" ==> each rooted arrow matching ('bar'->*)->'foo' pattern
 (plan by "foo" incoming children)
 "'bar o<o<'foo ==?>>" ==> ditto, plan by "bar" outgoing children
}}}

== Branching ==
{{{
 "('bar):'foo_?42/" ==> if 'foo' rooted then '42' else 'bar'
}}}

== Continuation chaining ==
{{{
 "(tt):'foo o_?t" ==>  cb w/ all x / (foo->(*->(*->(*->x)))) rooted
 "(t):'foo,'bar&;+42&" ==>  cb w/ ('foo'->42)
}}}