#summary The Entrelacs Abstract Machine

= Introduction =

The second major component of an Entrelacs System beside the ArrowsSpace is the _Entrelacs Abstract Machine_. It's a software machine which evals programs directly stored as arrows constructs.

Programs are defined according to the [EntrelacsLanguage Entrelacs Language]. This language is designed so that there is no difference between, source code, CST (Concrete Syntax Tree), and AST (Abstract Syntax Tree) in order to simplify meta-programming and persistent reflexivity.

The machine state itself consists in an arrows construct that programs may fetch and edit. So running programs may handle all the underlying machine components like:
  * environments,
  * continuations,
  * closures,
  * evaluated expression
  * ...

Concretely, the _Entrelacs Machine_ is largely inspired by the 
CaEK abstract machine of Flanagan et al. [1993]. The only major difference is that programs are hold by arrows structures rather than textual source code. Serialized text representation of the Entrelacs Language will only be supported for communication purpose.

_note: experimental features are tagged with #e# hereafter_

= The Language =
{{{
a ::= any arrow
x ::= an entrelacs arrow

// trivial expression
t ::=  	x // will be resolved as a variable
        | ("get" c) // resolve any arrow as a variable #e#
 	| ("escape" c) // escape any arrow (no substitution) #e#
 	| ("lambda" (x s)) // lambda expression

// serious expression
s ::=	("let" ((x t) s)) // binding
  	| ("let" ((x (t t)) s)) // application in binding
  	| (t t) // application
  	| ("let" ((x (t s)) s)) // serious in application in binding #e#
  	| (t s) // serious in application #e#

// program
p ::= s
}}}


= The Machine =

== Variable & values ==

{{{
<arrow> ::= any arrow
<entrelacs> ::= any entrelacs arrow
<escape> ::= ("escape" <arrow>) #e#
<get> ::= ("get" <arrow>) #e#
<lambda-expression> ::= ("lambda" (<arrow> <expression>))
<trivial> ::= <entrelacs> | <lambda-expression>
                       | <escape> | <get> #e#
<application> ::= (<trivial> <trivial>)
<serious-application> ::= (<trivial> <serious>) #e#
<binding> ::= ("let" ((<variable> <trivial>) <serious>))
<application-binding> ::= ("let" ((<variable> <application>) <serious>))
<serious-application-binding> ::= ("let" ((<variable> <serious-application>) <serious>)) #e#
<serious> ::= <binding> | <application-binding> | <binding>
              | <serious-application-binding> | <serious-binding> #e#
<expression> ::= <trivial> | <serious>
<closure> ::= ((<variable> <expression>) <environment>)
<program> ::= <expression>
}}}

== The Environment ==

{{{
<environment> ::= Eve | ((<variable> <value>) <environment>)
/* ((<variable> <value>) ((<variable> <value>)... ((<variable> <value>) Eve) ... )) */
}}}

== The Continuation chain, aka stack ==

{{{
<continuation-stack> ::= Eve | (<frame> <continuation-stack>)
/* (<frame> (<frame> ... (<frame> Eve) ... )) */
<frame> ::= (<variable> (<expression> <environment>))
}}}

== The Machine State ==

{{{
<machine-state> := (<program> (<environment> <continuation-stack>))
}}}

== System functions ==
Uncompleted list
 * head
 * tail
 * childrenOf
 * root
 * unroot
 * isRooted

== system variables ==
 * "@M" : get/set current <machine-state> 

== Machine transitions ==

=== the _resolve_ function ===

{{{
  Arrow resolve(Arrow trivial, Arrow environment)
}}}

Definition:
{{{
 * resolve(("escape" <a>), <e>) = <a> #e#
 * resolve(("lambda" (<x> <s>)), <e>) = ((<x> <s>) <e>) /* closure */
 * resolve("@M", <e>) = <machine-state>
 * resolve(("get" <x>), <e>) = resolve(<x>, <e>) #e#
 * resolve(<x>, ((<x> <value>) <e>)) = <value>
 * resolve(<x>, Eve) = <x> (Note: câ€™est beaucoup mieux que Eve)
 * resolve(<x>, ((<y> value>) <e>)) = resolve(<x>, <e>) /* x != y */
}}}

=== the _isTrivial_ function ===
{{{
   Boolean isTrivial(Arrow expression)
}}}

Definition:
{{{
 * isTrivial = 
     isEntrelacs(exp)
     || tail(exp) == "lambda"
     || tail(exp) == "escape" #e#
     || tail(exp) == "get" #e#
}}}

=== the eval function ===

Pseudo-C algo:
{{{
Arrow eval(program) {
  M = (program (Eve Eve))
  M = transition(M);
  while (head(head(M)) != Eve) {
    M = transition(M)
  }
  p = tail(M)
  e = tail(head(M))
  return resolve(p, e)
}}}

=== the _transition_ function ===

Pseudo-C algo:
{{{
#define _(a,b) = arrow(a,b)

Arrow transition(Arrow M) {
  if (isTrivial(p)) { // Trivial expression
     // p = v
     k = tail(tail(M))
     if (k == Eve) return // stop, program result = w
     if (tail(k) == continuation) { //special system continuation #e#
        // k = (continuation (<hook> <context>))
        hook = castAsPointer(tail(head(k)))
        context = castAsPointer(head(head(k))
        M = hook(M, context)
     } else {
       // k = ((x (ss ee)) kk)
       w = resolve(p, e)
       kk = head(k)
       f = tail(k)
       x = tail(f)
       ss = tail(head(f))
       ee = head(head(f))
       M = _(ss, _(_(_(x, w), ee), kk)) // unstack continuation, postponed let solved
     }
  } else if (tail(p)) == let) { //let expression family
     // p = (let ((x v) s))
     v = head(tail(head(p))
     x = tail(tail(head(p))

     if (tail(x) == "get") { x = resolve(x); } #e#

     // FIXME x == "@M" case

     if (isTrivial(v)) { // Trivial let rule
       // p = (let ((x t) s))
       t = v
       w = resolve(t, e)
       s = head(head(p))
       M = _(s, _(_(_(x, w), e), k))
     } else /* !isTrivial(v) */ { // Non trivial let rules
       // p = (let ((x (t0 s1) s))
       t0 = tail(v)
       v1 = head(v)
       if (!isTrivial(v1)) { // Very serious let rule #e#
         pp = _(let, _(_(p, s1), _(let, _(_(x, _(t0, _(get, p))), s)
         M = _(pp, _(e, k))
       } else /* isTrivial(v1)) */ { // Serious let rule
         // p = (let ((x t) s)) where t = (t0 t1)
         t1 = v1
         t0 = tail(t)
         t1 = head(t)
         w = resolve(t1, e)
         C = resolve(t0, e)
         if (tail(C) == "operator") { // System call special case
           // C = (operator (hook context))
           hook = getPointer(tail(head(C)))
           context = getPointer(head(head(C))
           r = hook(w, context)
           M = _(s, _(_(_(x, r), e), k))
         } else { // closure case
           // C = ((y ss) ee)
           ee = head(C)
	   y = tail(tail(C))
           ss = head(tail(C))
 	   M = _(ss, _(_(_(y, w), ee), _(_(x, _(s, e)), k))) // stacks up a continuation
         }
       }
     }
  } else if (!isTrivial(s = head(P))) { // Not trivial application #e#
     // p = (t s)
     pp = _(let, _(_(p, s), _(t, _(get, p))
     M = _(pp, _(e, k))

  } else { // Trivial application rule
     // p = (t0 t1)
     // Stacking not needed
     t0 = tail(p)
     t1 = head(p)
     w = resolve(t1, e)
     C = resolve(t0, e)
     if (tail(C) == operator) { // System call case
       // C = (operator (hook context))
       hook = getPointer(tail(head(C)))
       context = getPointer(head(head(C))
       r = hook(w, context)
       M = _(r, _(e, k))
     } else { // closure case
       // C = ((x ss) ee)
       x = tail(tail(C))
       ss = head(tail(C))
       ee = head(C)
       M = _(ss, _(_(_(x, w), ee), k))
     }
  }
}
}}}