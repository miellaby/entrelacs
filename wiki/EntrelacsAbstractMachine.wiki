#summary The Entrelacs Abstract Machine

= Introduction =

The Entrelacs Abstract Machine evals programs made up of arrows.

Its language is as well:
  * a functional language
  * a stack based language
  * a Call By Continuation style language
  * a query language Ã  la SQL
  * a fully reflexive language

= Machine State =

The Machine state is defined by a single arrow _M_ which is made up of:
  * _current_ : a "current" arrow
  * _program_ : to-be-evaluated program
  * _stack_ : a stack (as an arrow)
  * _continuation_ : a continuation

{{{
 M = (current ((stack program) continuation)))
}}}


= Real reflexivity =

Within a working Entrelacs systems, programs are directly stored as arrow structures (serialized text representation is only supported for communication purpose).

All in all, there is no difference between a piece of source code, a Concrete Syntax Tree (CST) and even an Abstract Syntax Tree (AST) in Entrelacs! Moreover, the current machine state (M) can be fully acceded and modified by programs. Programs can browse (introspection) and modify (intercession) such arrows in order to modify themselves for real!  Programs can not only modify themselves but also store their changes.

= The language =
== loading "current arrow" with ... ==
{{{
 42             tag "42"
 @AEFA00FA      a previously retrieved arrow identified by its internal ID
 "foo"          tag "foo"
 (some program) a closure
 t              the current arrow's tail
 h              the current arrow's head
 &              the arrow between the stack head and the current arrow
 M              the current state machine
     ->  Mhh       the current continuation
     ->  Mhth      the current program
     ->  Mhtt      the current stack
}}}

== Testing ==
{{{
 ~         sets current arrow to ( stack head ; current arrow ) linking arrow only if already stored, otherwise Eve
 ==        changes the current arrow to Eve if it isn't equal to stack head
 _         changes the current arrow to Eve if it isn't rooted
}}}

== arrows stacking ==
{{{
 <     adds current arrow to stack
 >     unstacks to current arrow
}}}

== continuation chaining ==
{{{
 :     adds current arrow to continuation chain (supposed to be closure but not necessary) 
 /     cut = replaces current continuation with next continuation
 ;     unchains next continuation without make it current
 ????  swaps current continuation with next continuation (TBC)
}}}

== branching ==
{{{
 ? cuts if current arrow is Eve
}}}

== continuation mapping ==
{{{
 i map/cc incomings of current arrow
 o map/cc outgoings ...
}}}

== syntaxic sugars ==
{{{
 'foo (then white space) <==> "foo"
 $foo (then white space) <==> 'foo o_?h
 , <==> < (stack)
 . <==> Mhh (current continuation)
}}}

= Examples =
The following examples are given in the form of unparsed program strings.

==  Basic browse ==
{{{
 "'foo" ==> "foo" arrow
 "'foo + 'bar &" ==> 'foo->'bar arrow
 "'foo o" ==> each arrow outgoing from 'foo'
 "'foo oh" ==> the head of each known arrow outgoing from 'foo'
 "'foo i_?t" ==> each x verifying (x->'foo') rooted
 "'foo i_?<t<'bar ==?>>" ==> each rooted arrow matching ('bar'->*)->'foo' pattern
 (plan by "foo" incoming children)
 "'bar o<o<'foo ==?>>" ==> ditto, plan by "bar" outgoing children
}}}

== Branching ==
{{{
 "('bar):'foo_?42/" ==> if 'foo' rooted then '42' else 'bar'
}}}

== Continuation chaining ==
{{{
 "(tt):'foo o_?t" ==>  cb w/ all x / (foo->(*->(*->(*->x)))) rooted
 "(t):'foo,'bar&;+42&" ==>  cb w/ ('foo'->42)
}}}