#summary The Entrelacs Abstract Machine

= Introduction =

The Entrelacs Abstract Machine evals programs built with arrows.

Its language is as well:
  * a functional language
  * a stack based language
  * a Call By Continuation style language
  * a query language Ã  la SQL
  * a fully reflexive language

= Machine State =

The Machine state itself is fully defined by a single arrow M = (current ((stack program) continuation))) where
  * _current_ : a "current" arrow
  * _program_ : to-be-evaluated program
  * _stack_ : a stack (as an arrow)
  * _continuation_ : a continuation

= Real reflexivity =

* The current machine state M can be acceded and modified by programs.
* Programs can modify themselves in a persistent way.
  * Programs can be serialized and communicated in the form of character strings, but once assimilated by an Entrelacs system, programs reside in the form of regular arrows.
  * Such an arrow acts as well as a piece of source code, a Concrete Syntax Tree and even an Abstract Syntax Tree (AST)!
  * Programs can browse (introspection) and modify (intercession) such arrows in order to modify themselves for real!

= The language =
== loading "current arrow" ==
{{{
 42             tag "42"
 @AEFA00FA      previously retrieved arrow
 "foo"          tag "foo"
 (some program) closure
 t              current arrow tail
 h              current arrow head
 &              ( stack head ; current arrow ) link
 M              current state machine
  ->  Mhh       current continuation
  ->  Mhth      current program
  ->  Mhtt      current stack
}}}

== Testing ==
{{{
 ~         ( stack head ; current arrow ) pair -> arrow if stored only, otherwhise Eve
 ==        current arrow set to Eve if not equal to stack head
 _         current arrow set to Eve if not rooted
}}}

== arrows stacking ==
{{{
 < add current arrow to stack
 > unstack to current arrow
}}}

== continuation chaining ==
{{{
 : add current arrow to continuation chain (supposed to be closure but not necessary) 
 / cut = replace current continuation with next continuation
 ; unchain next continuation without make it current
 ???? swap current continuation with next continuation (TBC)
}}}

== branching ==
{{{
 ? if current arrow is Eve then cut
}}}

== continuation mapping ==
{{{
 i incomings of current arrow
 o outgoings ...
}}}

== syntaxic sugars ==
{{{
 'foo (then white space) <==> "foo"
 $foo (then white space) <==> 'foo o_?h
 , <==> < (stack)
 . <==> Mhh (current continuation)
}}}

= Examples (in the form of unparsed strings) =
==  Basic browse ==
{{{
 "'foo" ==> "foo" arrow
 "'foo + 'bar &" ==> 'foo->'bar arrow
 "'foo o" ==> each arrow outgoing from 'foo'
 "'foo oh" ==> the head of each known arrow outgoing from 'foo'
 "'foo i_?t" ==> each x verifying (x->'foo') rooted
 "'foo i_?<t<'bar ==?>>" ==> each rooted arrow matching ('bar'->*)->'foo' pattern
 (plan by "foo" incoming children)
 "'bar o<o<'foo ==?>>" ==> ditto, plan by "bar" outgoing children
}}}
== Branching ==
{{{
 "('bar):'foo_?42/" ==> if 'foo' rooted then '42' else 'bar'
}}}
== Continuation chaining ==
{{{
 "(tt):'foo o_?t" ==>  cb w/ all x / (foo->(*->(*->(*->x)))) rooted
 "(t):'foo,'bar&;+42&" ==>  cb w/ ('foo'->42)
}}}