#summary More detailed description of the first ArrowsSpace prototype

This page describes the first ArrowsSpace prototype.

== Architecture overview ==

The ArrowsSpace software prototype consists in a thread-safe library (EntrelacsLibrary) providing operators to compose, root, and browse arrows in a single file on the host file system.

An HTTP/REST server is also planed on top of this library so that local or remote clients may simultaneously access a same AS.

== Complex objects support ==

The prototype will handle 2 types of objects in addition with regular arrows (ie. references pairs). That is:
  * _blobs_, ie. *large* binary strings,
  * _tags_, ie. *short* char strings (C-Like NULL-terminated).

Reminder: Despite _blobs_ and _tags_ are raw binary objects, they are still considered and handled like arrow constructs, namely _entrelacs_ (discrete reentrant structures of arrows).

23/02/09: Still studied: An additional _small_ native object for very short piece of data. It has to fit on a single storage cell.

24/05/10: Work in progress. Tuples (a set of more than 2 references) may be natively stored in a optimized way as well.

== Content storage policy ==

The persistence file is operated as a bank of storage units called _cells_.

One cell :
  * is both identified and positioned by a cell address,
  * can store one cell address and few additional data.

A regular arrow being a pair of arrows, it is consequently stored as a pair of cell addresses into 2 or more cells.

Atomistic arrows (blobs and tags) are also stored into cells like regular arrows. Data are taken into slices and stored in several cells separated by a predictable offset.

Contrary to tags, blobs may be very long, so one stores its whole hash signature before its content in order to accelerate existing singleton identification.

Not date data strings must not be mixed up with existing data. One needs to jump over conflicting cells up to the next valid slice of string. Some bits are reserved to store an offset multiplier on this purpose.

== Connectivity ==

For each newly assimilated arrow _a_, one also attaches 2 back-references to its ends (head and tail) definition, that is:
  * _a_ reference in a cell "after" _a.tail_ definition,
  * _a_ reference in a cell "before" _a.head_ definition.

These back-references form an index to browse all children arrows of a given arrow.

See hereafter a better meaning of "after" and "before" expressions.

== Overview of stored data ==

For each arrow, one needs to store:
  * its definition, that is
     * two arrow references for a pair
     * a C string preceded by its (short) checksum for a tag
     * a binary string preceded by its cryptographic signature for a blob.
  * its root flag (one mutable bit)
  * its connectivity data, that is:
     * a list of back-references to incoming and outgoing children
     * a total children counter (TBC)

== cell categories ==

As different kinds of data may be found in a cell, one needs to identify a cell content by few bit length value named "category" hereafter.

Categories so far:
  * PAIR = non-rooted regular arrow definition first storage cell
  * ROOT = rooted regular arrow first storage cell
  * BLOB = BLOB first storage cell
  * TAG = TAG first storage cell
  * REMAIN = remaining part of an arrow definition. Such a cell complete a "pair", "root", "blob", "tag" cell.
  * CHILD = reference to a child incoming/outgoing arrow

Restriction: Only regular arrows can be rooted, not blob or tag.

A variable-width encoding helps sparing bits for other purposes:
  * code 1 =>REMAIN + the 7 remaining bits store an "Offset factor".
  * code 01 => PAIR + the 6 remaining bits store a "ref counter".
  * etc.

== About hash functions ==

One makes use of an hash function to compute an arrow's _open address_ depending on its type:
  * For a _blob_, one uses a cryptographic unambiguous hash function (SHA).
  * For a _tag_, one uses a simpler checksum. When comparing an assimilated tag with a potential copy, one must check every char of the string.
  * For a regular arrow (linking a _tail_ to a _head_), one makes an hash out of the tail and head's respective hash codes. The hash function should be commutative (ToBeConfirmed) so that one may deduce an arrow hash code by combining its furthest ancestor hash codes rather than fetching every intermediate parent arrows.

The overall hash function _h_ consequently verifies :
  * _h_(Pair) = some_math_of(h(tail(Pair)), h(head(Pair))) 
  * _h_(Tag) = checksum(Tag)
  * _h_(Blob) = sha(Blob) (or any cryptographic hash function).

== Double Hashing to move apart related cells ==

One could decide to reserve and fill up a set of consecutive cells to store several slices of a same arrow definition (blob, tag...). But this naive approach would lead to _data cluttering_.

A better approach consists in separating data slices by a variable offset. This offset is computed to be different for each arrow in order to minimize collisions. This particular strategy is called DoubleHashing.

Suggestion: truncating a bigger hash modulo twin prim numbers. H % p1 for the open address, H % p2 for the separation offset.

== Coalesced Hashing ==

So arrows, blobs and tags definition can't fit on a single cell. And one chooses to take them into slices and to dispatch them on many cells separated by a predictable offset.

But there's a risk some cells needed to store our data are already used. One must jump over such busy cells when storing and retrieving data.

Every cell consequently hosts a "jump factor" to jump over colliding cells following in a string sequence. This strategy is vaguely related to CoalescedHashing.

The jump factor doesn't need to be a fully qualified cell address. It's only a count of the offset to shift until the next relevant cell.

The jump factor max value is low, but so is the probability of many repeated *consecutive* collisions.

Note coalesced hashing may not be needed for some data (children back references) as one might mix them with polluting data at the condition one consolidates the data.

Note: The first values of the "jump factor" might actually corresponds to the number of valid bytes within the last cell of a string.

ToBeConfirmed: Offsets are slightly different depending on usage (probing, back-refs dispatching, string slice dispatching) to avoid cluttering even more.

Some misc candidate offsets:
 * offset for probing = h % p2 (p2 = second twin prim number)
 * offset between string slices = swapBytes(h) % p2
 * offset between back-refs = neg(h) % p2

Still studied: A cell could store more than one of addresses. Collocation for small object managed by flag bits.

== Arrow typical footprint ==

Finally, here is the ideal (no conflict) footprint of an arrow assimilated as _i_ (its ID). _i_ goes out a _tail_ arrow and comes into an _head_ arrow (two other ID). _i_ is also referred by several incoming or outgoing children arrows.
{{{
//  Cell# Flag     Content
// [...]
//  i-4o  0        0
// [...]
//  i-3o  IN       some incoming child id
// [...]
//  i-2o  IN       some incoming child id
// [...]
//  i-o   IN       some incoming child id
// [...]
//  i     PAIR     tail id
// [...]
//  i+o   REMAIN   head id
// [...]
//  i+2o  REMAIN   H(i) | children counter
// [...]
//  i+3o  OUT      some outgoing child id
// [...]
//  i+4o  OUT      some outgoing child id
// [...]
//  i+5o  OUT      some outgoing child id
// [...]
//  i+6o  0      0
// [...]
}}}

== RAM Cache ==

When needed, arrows climb up to a level 1 (RAM) memory device. This memory is used as a fine-grained cache of level 0 cells. 
See ArrowsCache for further details.

== Garbage Collector ==

The AS features a garbage collection process which spares rooted arrows and all their "ancestors" and gets back resources used by no more rooted nor referred arrows.

On this purpose, a reference counter is attached to every arrow. This counter is incremented each time a new arrow is incoming/outgoing  from/to the given arrow. It is decremented when such a child arrow is deleted by the garbage collector. When both an arrow is non-rooted and has 0 children, one can recycle its storage resources.

The GC proceeds to-be-deleted arrows in an incremental way. Its job is dispatched on many transactions to avoid CPU overhead. Since arrows are not deleted immediately, they may be saved from deletion by being rooted or linked back. An additional check of deletion criteria is performed just before the actual deletion.

Still studied: The children counter definition range is short. When it reaches its max value, one simply postulates one can't change it anymore. It means the corresponding arrow will never be deleted. (ToBeConfirmed)

Actually, there is a small difference between a deleted cell and an empty cell, because of the "open addressing" way to resolve conflicts. When deleted, a cell is loaded with a "stuffing" value which prevents the including "open block" to be cut. See OpenAddressing for details.

== more ==
=== candidate hash functions so far ===
For practical reasons, the hash function should be commutative on structure of pairs. To be done.

     * key hash = f(tail, head) = ((head << 24) & tail) % P0
     * drone hash = g(tail, head) = ((head << 24) & tail) % P1
        * where P0 and P1 are twin prims near mem0 size 2^24
     * BLOB hash = truncated SHA-2
     * TAG hash = simpler checksum, like in http://www.cse.yorku.ca/~oz/hash.html

== even more ==

cf. InProgress