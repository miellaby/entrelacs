#summary More detailed description of the first ArrowsSpace prototype

This page describes the first ArrowsSpace prototype.

== Architecture overview ==

The ArrowsSpace software prototype consists in a thread-safe library (EntrelacsLibrary) providing operators to compose, root, and browse arrows in a single file on the host file system.

An HTTP/REST server is also planed on top of this library so that local or remote clients may simultaneously access a same AS.

== Complex objects support ==

The prototype will handle several types of complex objects in addition with regular arrows (ie. references pairs). That is:
  * _blobs_, ie. *large* binary strings,
  * _tags_, ie. *short* binary strings,
  * _tuple_, ie. an ordered set of n (n >= 1) arrows
  * _small_, a piece of raw data which is small enough to fit in an arrow storage cell.

Reminder: Despite _blobs_, _tags_ and _smalls_ are raw binary objects, they are still treated like their equivalent arrow constructs, namely _entrelacs_ (discrete reentrant structures of arrows).

== Mass storage usage ==

The persistence file is operated as a bank of storage units called _cells_.

One cell :
  * is identified and located by a cell address,
  * may contain a pair of addresses and/or a couple of other things.

A regular arrow being a pair of arrows, it is consequently stored as a pair of addresses into a single cell.

Raw data (blobs and tags) are also stored into cells like regular arrows. They are taken into slices and stored in several cells separated by a predictable offset.

Note that contrary to tags, blobs may be very long, so one stores its unique hashed signature before its data in order to accelerate existing singleton identification.

Note data strings must not be mixed up with existing data. One needs to jump over conflicting cells up to the next valid slice of string. Some bits are reserved to store an offset multiplier on this purpose (namely _jump_).

== Open Addressing ==

One relays on OpenAddressing to manage conflicts within the storage space.
  * When an object definition can't be stored at its expected location because of some already present content, one repeatedly shifts the storage location by a variable but predictable offset until one finds a free cell.
  * When one looks for something, one starts a search from the object expected location, and one probes for the object until one reaches the object (hit!) or an empty cell (miss!).

== Little Thumbling's algorithm ==

An issue with Open Addressing is that one can't empty a cell without breaking one or several sequences of busy cells that one must normally go through to find existing content.

A solution consists in incrementing a dedicated "more" counter on every cell visited from the default location up to the actual location of a newly stored object. These counters are comparably decremented upon object removal. When probing, one knows one should keep on going if the empty cell has a "more" counter greater than zero.

== Connectivity ==

For each newly assimilated arrow _a_, one also attaches 2 back-references to its ends (head and tail) definition, that is:
  * _a_ reference in a cell "after" _a.tail_ definition,
  * _a_ reference in a cell "before" _a.head_ definition.

These back-references form an index to browse all children arrows of a given arrow.

See hereafter a better meaning of "after" and "before" expressions.

== Overview of stored data ==

For each arrow, one needs to store:
  * its definition, that is
     * two arrow references for a pair
     * a C string preceded by its (short) checksum for a tag
     * a binary string preceded by its cryptographic signature for a blob.
  * its root flag (one mutable bit)
  * its connectivity data, that is:
     * a list of back-references to incoming and outgoing children
     * a total children counter (TBC)

== Cell categories ==

As different kinds of data may be found in a cell, one needs to identify a cell content by a few bit length value named "category" hereafter.
  * A: Arrow
  * I: Small (Integer)
  * S: Tag (String)
  * B: Blob
  * T: Tuple
  * R: Remaining
  * L: Last remaining
  * X: Redirection

R/L cells are used to store
 * either the continuation of a B, S, or T definition
 * or children list.

X contains addresses referring cells moved elsewhere because of extreme data cluttering.

== Hashing definitions ==

One makes use of an hash function to compute an arrow's _open address_ out of its definition.

The hash function is chosen after the type of arrow:
  * For a _blob_, one uses a cryptographic unambiguous hash function (SHA).
  * For a _tag_, one uses a simpler checksum. When comparing an assimilated tag with a potential copy, one must check every char of the string.
  * For a regular arrow, one hashes the tail and head's respective hash codes. The hash function might be commutative (ToBeConfirmed) so that one may deduce an arrow hash code by combining its furthest ancestor hash codes rather than fetching every intermediate parent arrows.

The overall hash function _h_ consequently verifies :
  * _h_(Pair) = some_math_of(h(tail(Pair)), h(head(Pair))) 
  * _h_(Tag) = checksum(Tag)
  * _h_(Blob) = sha(Blob) (or any cryptographic hash function).

== Double Hashing to move apart related cells ==

One could decide to reserve and fill up a set of consecutive cells to store several slices of a same arrow definition (blob, tag...). But this naive approach would lead to _data cluttering_.

A better approach consists in separating data slices by a variable offset. This offset has to be different for each arrow in order to minimize collisions. This particular strategy is called DoubleHashing.

Suggestion: truncating a bigger hash modulo 2 twin prim numbers. H % p1 for the open address, H % p2 for the separation offset.


== Coalesced Hashing ==

Complex object (tuples, blobs, tags) definitions can't fit in a single cell. One takes them into slices and dispatches them into many cells separated by a predictable offset.

But there's a risk some cells are already used. One must jump over such busy cells when storing and retrieving data.

Every cell consequently hosts a "jump factor" to jump over colliding cells. This strategy is vaguely related to CoalescedHashing.

The jump factor doesn't need to be a fully qualified cell address. It only counts the number of shift until the next relevant cell.

The jump factor max value is low, but so is the probability of many repeated *consecutive* collisions. In case of 

There are 3 offset to shift from a given location functions used for probing, back-refs dispatching, string slice dispatching) to avoid cluttering even more.

Some misc candidate offsets:
 * offset for probing = h % p2 (p2 = second twin prim number)
 * offset between string slices = swapBytes(h) % p2
 * offset between back-refs = neg(h) % p2

== Cells usage summary ==

Considering all the principles introduced above, here is the summary of cells usage.

===Cell structure per category===
This is a 8 bytes cell proposal.

====Definition starts=====

 * Arrows and _smalls_ definitions
{{{
        +---<category>
        |
 <more> A <--tail@------> <--head@------> <r><children> : an arrow
 <more> I <--data-----------------------> <r><children> : a small
}}}

 * Complex objects definition starts
{{{
 <more> T <--checksum--------> <--jump--> <r><children> : a tuple
 <more> S <--checksum--------> <--jump--> <r><children> : a tag
 <more> B <--checksum--------> <--jump--> <r><children> : a string
}}}

====Sequences====
 * Sequence of ends (for a tuple)
{{{
 <more> R <--end@-------> <--end@-------> <---jump----> : 2 ends of a tuple
 <more> L <--end@-------> <--end@-------> <size = 0/1 > : Last ends of a tuple
                                                           (size = 0 ==> 1 end only)
}}}

 * Sequence of slices (for blobs and tags)
{{{
 <more> R <-----slice------------------> <---jump----> : data slice of a blob/tag
 <more> L <-----slice-----><--nothing--> <--size-----> : last data slice of blob/tag
                                                          (last slice size stored in bytes)
}}}

 * Children list
{{{
 <more> R <--child@-----> <--child@-----> <---jump----> : 2 children
 <more> L <--child@-----> <--child@-----> <size = 0/1 > : last 2 children
                                                           (size = 0 ==> 1 child only)
}}}
 * Bounce! (extreme cluttering escape)
{{{
 <more> X <----moved@---> <--children@--> <nothing----> : Redirection
}}}

====Fields size====

This is a 8 bytes cell proposal.
 * _more_ counter : 5 bits
 * _category_ : 3 bits
 * _cell address_ (_tail@_, _head@_, _end@_, _moved@_, _children@_) : 3 bytes
 * _jump_ multiplier : 1 byte
 * _children_ multiplier : 7 bits
 * _root flag (r)_ : 1 bit
 * _size_ : 1 byte

====Fields usage====

 * _more_
    The "more" counter of the Little Thumbling's algorithm.

 * _category_
    The category indicates the inner structure of a cell and give information about its content. Note R/L cells are used to store different kinds of sequence (children lists, big object slices list, tuple ends list).

 * _jump_
    The "jump" multiplier allows to jump over unwanted content in case of storage conflict. Cells belonging to the same object definition or the same children list are linked together by the "jump" multiplier of R, T, S, or B cell. The next cell in the sequence is located at {{{@cellR + ( jump + 1) * offsetNext}}}.

 * _children_
   Every cell containing the beginning of an arrow/object definition is also the first cell of a "children sequence", a list of cells separated by a dedicated "children offset". The "children" multiplier is an offset multiplier like _jump_ which allows jumping over unrelated content up to the first real children cell. The beginning of the children list of an arrow at _@parent_ is located at {{{@parent + children * offsetChildren(parent)}}}. Note that "children" to zero means the arrow has no child.

 * _root bit_
   The root flag as a mutable bit

 * _size_
   The last cell of an object definition (or a children list) may be partially full. The _size_ field allows to ignore stuffing value.

===Bounce cell===

In case of extreme data cluttering, a cell may be moved in a safer place and replaced by a bounce cell containing two full addresses.
 * One to the moved cell,
 * One to the children list (if the moved cell was a definition start)

== Arrow typical footprint ==

Finally, here is the ideal (no conflict) footprint of an arrow assimilated as _i_ (its ID). _i_ goes out a _tail_ arrow and comes into an _head_ arrow (two other ID). _i_ is also referred by several incoming or outgoing children arrows.

|| To be done ||

== RAM Cache ==

When needed, arrows climb up to a level 1 (RAM) memory device. This memory is used as a fine-grained cache of level 0 cells. 
See ArrowsCache for further details.

== Garbage Collector ==

The AS features a garbage collection process which spares rooted arrows and all their "ancestors" and gets back resources used by no more rooted nor referred arrows.

When both an arrow is non-rooted and has 0 child, one can recycle its storage resources.

The GC proceeds to-be-deleted arrows in an incremental way. Its job is dispatched on many transactions to avoid CPU overhead. Since arrows are not deleted immediately, they may be saved from deletion by being rooted or linked back. An additional check of deletion criteria is performed just before the actual deletion.

== Proposal of hash functions ===
Suggestion: the arrow key hash function might be commutative on structure of pairs. To be done.

     * arrow key hash = f(tail, head) = ((head << 24) ^ tail) % P0
     * drone hash = g(tail, head) = ((head << 24) ^ tail) % P1
        * where P0 and P1 are twin prims near mem0 size 2 ^ 24
     * BLOB key hash = SHA-2 (truncated for key)
     * TAG key hash = simpler checksum, like in http://www.cse.yorku.ca/~oz/hash.html
     * sequence hash = (to be done)
     * children hash = (to be done)