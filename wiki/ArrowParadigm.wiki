#summary The EntrelacsSystem relays on the "arrow" paradigm.
#labels Featured

=Introduction=

The EntrelacsSystem deals only with _arrows_. Its credo might be _Everything is an arrow_. This is the _*Arrow Paradigm*_.

==Definition of a regular arrow==
<img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrows1.png' align=right>   

An _arrow_ -as defined within the EntrelacsSystem- is an unique immutable oriented pair of arrows.

  * an arrow is a "pair of arrows". It means both ends of each arrow are two other arrows.  In other words, *an arrow graph doesn't contain any node.*
  * an arrow is "oriented". It means the pair (A,B) is distinct from (B,A).

It has been said an arrow is "unique". It means the EntrelacsSystem deals with arrows as pure (uniquely definable) mathematical objects. Redundant constructs are rejected. It implies the system can tell whether two arrows are equals or not. This equality relationship is an isomorphism (?).

It has been said an arrow is "immutable". It means again the EntrelacsSystem deals with arrows as pure mathematical objects. One can't change a number: PI is PI forever, and so is any definable arrow.


==Definition of an _entrelacs_==

An _entrelacs_ is a set of arrows connected to each other, forming a closed graph as a whole.

A set of arrows can be identified as an entrelacs if it contains at least one arrow whom the set of ancestors matches the considered set. See a counter-example hereafter.

Actually it means that every arrow belongs to a related entrelacs consisting in this arrow and all its _ancestors_.

|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/entrelacs1.png   ||Here is a introduction of few entrelacs (and one counter-example)||

==Definition of a _prim entrelacs_==

A _prim entrelacs_ is an entrelacs which is so much interlaced it doesn't contain smaller entrelacs.

|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/eve.png   || this arrow is also a "prim entrelacs". It is named _eve_ (certainly because it has no parent) ||
||http://entrelacs.googlecode.com/svn/trunk/doc/pictures/composed1.png|| this arrow is not a "prim entrelacs" but it embeds two ones ||

"Prim entrelacs" look like atomistic pieces of data. They can't be divided in smaller parts; they are closed; and they got finished boundaries. It implies you can handle them, name them, count them, ordering them, etc as you can do with, says, numbers.

==atomistic binary arrows==
The _Entrelacs System_ allows to store "unique" and "immutable" flat data as well.

However, this feature doesn't deny the _arrow paradigm_, because the entrelacs underlying theory demonstrates such atomistic data are equivalent to _prim entrelacs_.

In other mean, such binary data may be seen as some sort of arrows as well. See AtomEntrelacEquivalency for further reading.
|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/bin1.png   ||Binary things may be seen as encoded big prim entrelacs.||

==Arrow connectivity==
|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrow1.png || an _arrow_, its _head_, its _tail_, its _incoming children_ arrows, its _outgoing children_ ||
  * an arrow is an oriented pair of arrows.
  * the first arrow in the pair is named the "tail".
  * the last arrow in the pair is named the "head".
  * one says an arrow "goes out" its tail arrow.
  * one says an arrow "comes into" its head arrow.
  * from its tail point of view, an arrow is an "outgoing" arrow.
  * from its head point of view, an arrow is an "incoming" arrow.
  * An arrow may have many incoming and outgoing arrows. One calls them "children" arrows.
  * The arrows which are reachable by recursively following head/tail definitions from a given arrow are called the arrow's "ancestors". Remember: The arrow and its ancestors form an _entrelacs_.

==arrow / entrelacs equivalency==

An arrow is equivalent in every aspect of its to the entrelacs formed by it and all its ancestors. Inversely, an entrelacs is equivalent in every aspect of its to at least one of its arrows (a prim entrelacs is equivalent to any of its arrows).

In other words, an entrelacs is an arrow, and an arrow is an entrelacs. Actually, one may substitute indifferently these two concepts each other.

==Definition of rooted arrows==

All the system knowledge state at a given time might be represented in one unique arrow containing all the useful information in its definition.

However, it's more convenient to represent the system top-level context as a set of distinct arrows. These arrows are called _rooted arrows_.

Rooted arrows are concretely regular arrows flagged with a "root" mark. This "root" boolean property is the only mutable property of an arrow within the system storage space.  The "root" property typically corresponds to a dedicated flag bit stuck to the arrow definition within the storage space.

|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/rooted1.png   || this arrow is "rooted".||
See the graphic notation here (Lambda / check mark).

==About garbage collector==

Any mathematically definable arrow may be classified in one of these 2 groups at a given time within a given system.
 * first case: the arrow belongs to the definition of one or several rooted arrows and/or it is a rooted arrow by itself.
 * second case: the arrow is neither a rooted arrow nor an ancestor of any rooted arrow.

Arrows from the first group is useful information and have to be preserved. Arrows in the second group are garbage. They may be swiped from the system to reclaim storage space.

==arrow assimilation==

At any time, system inputs are converted into arrows before any other further processing. This process converts a structured stream of data into the corresponding arrows graph. It is called "assimilation".

"Assimilation" takes place at system boundaries. Once "assimilated", something like a source code is not in a textual representation any more. It resides as a structured arrows sub-graph of the whole system graph.

==redundancy free principle==

For practical reasons, one definable arrow -whatever it is a regular pair or a binary datum- has to be represented only once in the whole system storage space. This constraint is verified during the "assimilation" process.

==immutability==

As one arrow might be an ancestor of many other arrows, one arrow can't be modified once stored in the system space.

|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/average1.png   || this average entrelacs embeds arrows which are several times ancestors of children arrows.||

System changes are conducted by rooting/un-rooting operations. Please take into considerations such operations recycle most of the material (arrows) involved into the change thanks to the redundancy free principle of the assimilation process.

==arrow modeling==

You don't know how to represent useful information with arrows only? See ArrowModeling for solutions.