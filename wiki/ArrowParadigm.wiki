#summary Everything is an arrow
#labels Featured

=Introduction=

The way current computer systems are managing information is shaped by the old [BoxValueParadigm Box/Value paradigm] which consists in turning information into graphs of boxed data values.

The [http://code.google.com/p/entrelacs/ Entrelacs Manifesto] proposes to build up a brand new computing stack based upon a radically different paradigm introduced hereafter: the _*Arrow paradigm*_.

====At a glance====
 * no more than one building block to _tell_ everything: the *arrow*
 * an arrow is an oriented pair of ... arrows. That's all.
 * an arrow is considered in its "canonical" or "unique" form. Every definable arrow is mapped to at most one physical representation per system.
 * an arrow is considered "immutable". The physical representation of an arrow can't be modified once placed.
 * an arrow is "connected" with its ends. The system may browse these connections in both way to explore all the information attached to every arrow.
 * one doesn't need anything else than arrows to represent information. The old "nodes vs. edges" duality from graph theory is rejected.
 * But raw data can still be handled as particular sorts of arrows, that is re-entrant constructs of arrows named _entrelacs_.

==Arrow==
<img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrows1.png' align=right>   

    ===a pair===
    An _arrow_ is basically a pair of arrows. *Arrow ends are not nodes but other arrows*. [http://en.wikipedia.org/wiki/Graph_theory Graph theory]^W^ doesn't cover arrow made constructs.

    ===oriented===

    The pair (A,B) is distinct from (B,A).

    Note that one may dismiss this requirement and build back oriented pairs by combining non-oriented pairs.

    ===unique===
    Syn. canonical, normed, hashed.

    An arrow-based system stores only one physical representation of the arrow (A,B) from A to B, whatever A and B two known arrows.

    Self-referring sets of arrows -that is _entrelacs_ as introduced hereafter- are also uniquely identified.

    ===immutable===

    An arrow is to be considered as a pure mathematical object. And in the same way that one can't "modify" a natural number like 2, one can't _modify_ an arrow within a system

    The system dynamic goes by assimilating new arrows and forgetting old ones.

    ===connected===

    Inside a given system, a certain arrow may be connected to many _children_ arrows, that is arrows whose one of both ends are the considered arrow.

    The system must be able to efficiently browse all these children as it forms _emerging information_. It's the basis of a new kind of system abilities.

==Wordlist==

<img align=right src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrow1.png'/>

Each arrow is an oriented pair of arrows.
  * The first arrow is the _tail_.
  * The last arrow is the _head_.
  * Tail and head are _ends_.
  * An arrow _goes out_ its tail.
  * An arrow _comes into_ its head.
  * From its tail point of view, an arrow is an _outgoing_ arrow.
  * From its head point of view, an arrow is an _incoming_ arrow.
  * Incoming and outgoing arrows are _children_.
  * Children, children of children, and so on, are _descendants_.
  * Ends, ends of ends, and so on, are _ancestors_.

==_Entrelacs_==

An _entrelacs_ is a set of intricated arrows forming an unique discrete connected construct. It means that any arrow from the set is the descendant/ancestor of all the other arrows of the set.

Theorem: (to be completed)

     A set of arrows E forms an entrelacs if and only if
         * whatever A, B 2 arrows in E,
         * A is a descendant B

One characterizes an entrelacs according to its topology, that is how many arrows it contains and how these arrows are connected together. One considers that *entrelacs which are isomorphic are identical*.



|| Examples: || http://entrelacs.googlecode.com/svn/trunk/doc/pictures/eve.png || http://entrelacs.googlecode.com/svn/trunk/doc/pictures/composed1.png ||
|| || [http://en.wikipedia.org/wiki/Orobouros Orobouros]^W^ which has no ancestor but itself ||<p align=center> 2 entrelacs linked by a regular arrow</p> ||

=== Entrelacs-Atoms Correspondence ===

Entrelacs act as atomic pieces of information.
 * They got finished boundaries
 * One can't identify smaller isolated components in them.
 * But one can *enumerate* them
 * They are no reason to discern its inner component. For example, Yin and Yang are not discernible from each other (what's true for one is true for the other). One may see such an entrelacs as a unique arrow.

To conclude, _entrelacs_ are equivalent in all respects to *atoms* like those found in [http://en.wikipedia.org/wiki/S-expression S-expression]^W^.

== Practical considerations ==

===Assimilation process===

All system inputs (network events, user actions, ...) must be _assimilated_ into arrows first before being processed by the system.

This "Assimilation" process also occurs when low-level processes produce new data, e.g. numbers obtained by mathematical operations.

Arrows uniqueness is enforced during assimilation by checking that no previous representation of each arrow exists in the storage space before adding one to it.

===Rooting===

From a theoretical perspective, the whole knowledge of a given system at given time might be defined as a single arrow _S_. _S_ definition would include all other known arrows. It would be the only movable "variable" of the computer system.

But, for practicability, one should rather represent the system knowledge as a set of distinct arrows, namely the _rooted arrows_.

A rooted arrow is an _assimilated_ arrow decorated with a "root" mark. It means that this arrow is considered "true" in the top-level context of the considered system.

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/rooted1.png'/><br/><u>some rooted arrow.</u><br/>(check mark notation)</p>

Arrow uniqueness induces that an arrows may be often simultaneously rooted and an ancestor of rooted arrows.

Thus, a system-level garbage collector must reclaim storage space by removing physical representations of arrows which are neither a _rooted_ arrow nor an _ancestor_ of any other rooted arrow.

==Handling of complex objects==

From a theoretical perspective, _arrows_ are the only building blocks needed to represent information.

However, a realist system should handle raw data -like binary strings- as well.

Thanks to the [AtomEntrelacEquivalency  Entrelacs-Atoms Correspondence], this doesn't deny the initial paradigm as _data_ eventually correspond to arrows.

<img align='right' src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/bin1.png'/>

More generally, an arrow based system may be extended to take into consideration advanced building blocks like _tuples_ or _bags_ *as long as* these complex objects are handled exactly in the same way as their equivalent arrow constructs, especially in terms of uniqueness, immutability, and connectivity.

For instance, when assimilating the "hello world" character string, an arrow based system must ensure that:
 * there is no more than one copy of the string in the whole storage space, 
 * the string can't be modified in place,
 * one may browse all the arrows connected to this string, like the programs which make use of "Hello world".

==Orthogonal persistence==

A practical arrow-based system should ensure the [http://en.wikipedia.org/wiki/Orthogonal_persistence orthogonal persistence]^W^ of arrows. It means that neither programs nor users are concerned by information persistence. The management of RAM, disks, caches, pages, and all the related garbage collection mechanisms should be totally transparent.

==Knowledge representation with arrows==

To get useful information structures with arrows, one may adapt many classical meta-models or even invent new ones. See ArrowModeling for further readings.

==Similarity with existing concepts==

Arrows are somewhat similar to [http://en.wikipedia.org/wiki/Cons cons cells]^W^, especially "hons" obtained by [http://en.wikipedia.org/wiki/Hash_consing "hash consing"]^W^. A definition of "hons" is given by the documentation of  [http://www.cs.utexas.edu/~moore/acl2/current/HONS.html the ACL2 system].

All in all, the Entrelacs manifesto proposal simply consists in performing system-wide _hash consing_, combined with transparent persistence and indexation.

The only invention of this paradigm might be that one considers non reducible systems of equations as materials to "bootstrap" the information system. For example the equation
_x = x x_ defines "Orobouros" while the simultaneous equations _x = y . y & y = x . x & x != y _ defines an arrow out of the Yin-Yang structure.

It's like "lambda calculus" without free variables as one may use lambda abstractions as constants and alpha-equivalence to check constant equality.

This approach is motivated by the desire to definitively merge relations and related elements in a single and same set. It leads to design a system where information is homogeneous and "scale-invariant" on the "meta" complexity scale.