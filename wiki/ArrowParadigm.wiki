#summary Everything is an arrow
#labels Featured

=Introduction=

The Entrelacs Manifesto proposes to handle information in the form of _arrows_ made constructs. This is the _*Entrelacs paradigm*_.

==The arrow==
<img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrows1.png' align=right>   

The _arrow_ is the first and only building block of information that the _Entrelacs paradigm_ needs for.
 
An _arrow_ is:
  * _a pair of arrows_: both ends of each arrow are two other arrows. *An arrow made structure doesn't contain any node, so it doesn't belong to [http://en.wikipedia.org/wiki/Graph_theory graph theory]. period.*
  *  _oriented_: the pair (A,B) is distinct from (B,A). Please note this point is not actually mandatory to get a fully expressive information model as one could easily map oriented links as constructs made of non-oriented arrows. 
  * _a singleton_: There is only one arrow (A,B) from A to B, whatever A and B two formerly defined arrows. The _entrelacs paradigm_ proposes to translate this uniqueness into the information system as well. Each mathematically definable arrow can't be mapped more than once in the whole information system.
  * _immutable_: An arrow is assimiled as a pure mathematical object. System processes and user interactions don't _modify_ already known arrows. They rather create new arrows and tend to forget oldest ones.
  * _connected_: Each arrow may be connected to many children arrows. One must easily be able to retrieve this list as it forms _emerging information_. It's the basis of a new kind of system abilities.

==Arrow connectivity and wording==
<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrow1.png'/></p>

Each arrow is an oriented pair of arrows.
  * the first arrow in the pair is named the "tail".
  * the last arrow in the pair is named the "head".
  * one says an arrow "goes out" its tail arrow.
  * one says an arrow "comes into" its head arrow.
  * from its tail point of view, an arrow is an "outgoing" arrow.
  * from its head point of view, an arrow is an "incoming" arrow.
  * each arrow may have many incoming and outgoing arrows. One calls them "children" arrows.
  * arrows reached by following head and tail links starting from a given arrow are called this arrow's "descendants".

==_Entrelacs_==

An _entrelacs_ is an unique set of _intricated_ arrows. It means:
  * any arrow from the set contains the whole set of arrows in its definition. In other words: whatever A & B two arrows from the set, A is an ancestor of B, and B is an ancestor of A.
  * uniqueness : One distinguishes each entrelacs regarding its topology (how its arrows are connected each other). Entrelacs which are isomorph are equal.

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/eve.png   '/><br/>this entrelacs is named _Eve_ (Eve has no ancestor but itself)</p>

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/composed1.png'/><br/>an arrow from _yin-yang_ to _triskel_ (two distinct entrelacs)</p>

Entrelacs behave like atomistic pieces of data. Like atoms, they can't be divided in smaller parts and they got finished boundaries. And last but not least, one can *enumerate* them, like natural numbers.

<img align='right' src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/bin1.png'/>
==Entrelacs / raw data equivalency==

The _arrows paradigm_ allows to define arrows out of raw data as well.
It doesn't deny the _everything is an arrow_ credo since all in all _entrelacs_ and _atomistic pieces of data_ are equivalent.

In other words, raw binary data corresponds to some sort of arrows as well. Mathematically, one says there's an isomorphism between the set of entrelacs and the set of natural numbers (ie. raw data).

Big notice: As any regular arrow, the EntrelacsSystem stores each piece of data in an "unique" and "immutable" way. For instance, one won't find more than one copy of "hello world" character string in the whole system storage space.

See AtomEntrelacEquivalency for further reading.

==arrow assimilation==

At each system iteration, system inputs (network events, user inputs, ...) are converted into arrows before being processed. This translation process is called "assimilation".

"Assimilation" ensures arrows uniqueness. Any definable arrow must correspond to a _singleton_. There can't be more than one copy in the whole system space.

"Assimilation" takes place at system boundaries. But it also deals with information produced by system processes, like when some software get a new number by adding two natural numbers.

==rooted arrows==

The whole system knowledge might be represented with a single arrow whose definition would embed all known information.

But it's more convenient to represent the system top-level context as a set of distinct arrows.

Such arrow are call _rooted arrows_. They corresponds to regular arrows flagged with a "root" mark, that is a "root" boolean property added to the arrow definition within the system storage space.

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/rooted1.png'/><br/>some rooted arrow. Note the check mark (Lambda) notation.</p>

Arrows representation uniqueness induces rooted arrows may as well be ancestors of other rooted arrows. The system garbage collector can only reclaim storage resources of an arrow which is neither a rooted arrow nor an ancestor of any remaining rooted arrow.

==immutability==

<img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/average1.png' align='right'/>

As one arrow might be the ancestor of many other arrows, it can't be modified once stored in the system space.

Modifying an existing arrow definition within the knowledge system consists in rooting the new updated arrow then un-rooting the existing definition. This process luckily recycles most of the arrow ancestors thanks to the arrow uniqueness rule of assimilation.

==rooted arrows==

The whole system knowledge might be represented with a single arrow whose definition would embed all known information.

But it's more convenient to represent the system top-level context as a set of distinct arrows.

Such arrow are call _rooted arrows_. They corresponds to regular arrows flagged with a "root" mark, that is a "root" mutable boolean property added to the arrow definition.

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/rooted1.png'/><br/>some rooted arrow. Note the check mark (Lambda) notation.</p>

Arrows uniqueness induces rooted arrows are likely ancestors of other  rooted arrows as well.

An Entrelacs system garbage collector simply needs to reclaim storage resources of arrows which are neither a rooted arrow nor an ancestor of any remaining rooted arrow.

==extension of the paradigm to any arrow-equivalent objects==

The arrow paradigm can be applied to more complex information building blocks, like _tuples_, _bags_, raw data, as long as these objects are considered as their arrow based equivalent constructs, especially in terms of uniqueness, connectivity, and immutability.

==arrows based knowledge representation==

To get useful information structures with arrows, one can adapt many classical models and even invent new ones. See ArrowModeling for further readings.