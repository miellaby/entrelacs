#summary The EntrelacsSystem relays on the "arrow" paradigm.
#labels Featured

=Introduction=

The EntrelacsSystem's proposal consists in digitalizing information as structures made out of _arrows_. Its credo might be _Everything is an arrow_. Let's introduce this new _*Arrow Paradigm*_.

==The arrow==
<img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrows1.png' align=right>   

An _arrow_ is an _unique immutable oriented pair of arrows_.

It means:
  * _a pair of arrows_: both ends of each arrow are two other arrows. *An arrow graph doesn't contain any node.*
  *  _oriented_: the pair (A,B) is distinct from (B,A).
  * _unique_: There is only one arrow linking A to B, whatever A and B: two well-defined arrows. The EntrelacsSystem ensures this uniqueness in its arrows storage space as well. Each mathematically definable arrow is present at most once in the whole system address space.
  * _immutable_: The system doesn't modify an arrow definition once it's stored within the system storage space. System interactions produce new arrows instead.

==The _entrelacs_==

An _entrelacs_ is an unique set of _intricated_ arrows. It means:
  * any arrow from the set contains the whole set of arrows in its definition. In other words: whatever A & B two arrows from the set, A is an ancestor of B, and B is an ancestor of A.
  * uniqueness : two entrelacs are equivalent when they are

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/eve.png   '/><br/>this is an entrelacs named _Eve_ (whose unique arrow has no ancestor except itself)</p>

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/composed1.png'/><br/>an arrow from _yin-yang_ to _triskel_ (two distinct entrelacs)</p>

"Prim entrelacs" behave like atomistic pieces of data. Like atoms, they can't be divided in smaller parts and they got finished boundaries. You can handle them, name them, count them, ordering them, etc as you can do with, says, numbers.

==|E to |R isomorphism==
The _Entrelacs System_ allows to store "unique" and "immutable" flat data as well.

However, this feature doesn't deny the _arrow paradigm_, because the entrelacs underlying theory demonstrates such atomistic data are equivalent to _prim entrelacs_.

In other mean, such binary data may be seen as some sort of arrows as well. See AtomEntrelacEquivalency for further reading.
|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/bin1.png ||
|| Binary things may be seen as encoded big prim entrelacs. ||

==Arrow connectivity==
|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrow1.png ||
|| an _arrow_, its _head_, its _tail_, its _incoming children_ arrows, its _outgoing children_ ||

  * an arrow is an oriented pair of arrows.
  * the first arrow in the pair is named the "tail".
  * the last arrow in the pair is named the "head".
  * one says an arrow "goes out" its tail arrow.
  * one says an arrow "comes into" its head arrow.
  * from its tail point of view, an arrow is an "outgoing" arrow.
  * from its head point of view, an arrow is an "incoming" arrow.
  * An arrow may have many incoming and outgoing arrows. One calls them "children" arrows.
  * The arrows which are reachable by recursively following head/tail definitions from a given arrow are called the arrow's "ancestors". Remember: The arrow and its ancestors form an _entrelacs_.

==arrow / entrelacs equivalency==

An arrow is equivalent in every aspect of its to the entrelacs formed by it and all its ancestors. Inversely, an entrelacs is equivalent in every aspect of its to at least one of its arrows (a prim entrelacs is equivalent to any of its arrows).

In other words, an entrelacs is an arrow, and an arrow is an entrelacs. Actually, one may substitute indifferently these two concepts each other.

==Definition of rooted arrows==

All the system knowledge state at a given time might be represented in one unique arrow containing all the useful information in its definition.

However, it's more convenient to represent the system top-level context as a set of distinct arrows. These arrows are called _rooted arrows_.

Rooted arrows are concretely regular arrows flagged with a "root" mark. This "root" boolean property is the only mutable property of an arrow within the system storage space.  The "root" property typically corresponds to a dedicated flag bit stuck to the arrow definition within the storage space.

|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/rooted1.png ||
|| this arrow is "rooted".||
See the graphic notation here (Lambda / check mark).

==About garbage collector==

Any mathematically definable arrow may be classified in one of these 2 groups at a given time within a given system.
 * first case: the arrow belongs to the definition of one or several rooted arrows and/or it is a rooted arrow by itself.
 * second case: the arrow is neither a rooted arrow nor an ancestor of any rooted arrow.

Arrows from the first group is useful information and have to be preserved. Arrows in the second group are garbage. They may be swiped from the system to reclaim storage space.

==arrow assimilation==

At any time, system inputs are converted into arrows before any other further processing. This process converts a structured stream of data into the corresponding arrows graph. It is called "assimilation".

"Assimilation" takes place at system boundaries. Once "assimilated", something like a source code is not in a textual representation any more. It resides as a structured arrows sub-graph of the whole system graph.

==redundancy free principle==

For practical reasons, one definable arrow -whatever it is a regular pair or a binary datum- has to be represented only once in the whole system storage space. This constraint is verified during the "assimilation" process.

==immutability==

As one arrow might be an ancestor of many other arrows, one arrow can't be modified once stored in the system space.

|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/average1.png   ||
|| this average entrelacs embeds arrows which are several times ancestors of children arrows.||

System changes are conducted by rooting/un-rooting operations. Please take into considerations such operations recycle most of the material (arrows) involved into the change thanks to the redundancy free principle of the assimilation process.

==arrow modeling==

You don't know how to represent useful information with arrows only? See ArrowModeling for solutions.