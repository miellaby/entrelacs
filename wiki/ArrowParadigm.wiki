#summary The EntrelacsSystem relays on the "arrow" paradigm.
#labels Featured

=Introduction=

The EntrelacsSystem's proposal consists in digitalizing information as structures made out of _arrows_. Its credo might be _Everything is an arrow_. Let's introduce herein this new _*Arrow Paradigm*_.

==The arrow==
<img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrows1.png' align=right>   

An _arrow_ is:
  * _a pair of arrows_: both ends of each arrow are two other arrows. *An arrow graph doesn't contain any node.*
  *  _oriented_: the pair (A,B) is distinct from (B,A).
  * _unique_: There is only one arrow  (A,B) from A to B, whatever A and B two formerly defined arrows. The EntrelacsSystem ensures this uniqueness in its arrows storage space as well. Each mathematically definable arrow is present at most once in the whole system address space.
  * _immutable_: The system doesn't modify an arrow definition once it's stored within the system storage space. System interactions produce new arrows instead.
  * _connected_: Each arrow may be involved in many connections with children arrows. Those connections are easily accessible. It form information to produce new knowledge and system usefulness.

==The _entrelacs_==

An _entrelacs_ is an unique set of _intricated_ arrows. It means:
  * any arrow from the set contains the whole set of arrows in its definition. In other words: whatever A & B two arrows from the set, A is an ancestor of B, and B is an ancestor of A.
  * uniqueness : One distinguishes each entrelacs regarding its topology (how its arrows are connected each other). Two entrelacs which are isomorphic are equals.

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/eve.png   '/><br/>this entrelacs is named _Eve_ (Eve has no ancestor but itself)</p>

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/composed1.png'/><br/>an arrow from _yin-yang_ to _triskel_ (two distinct entrelacs)</p>

Entrelacs behave like atomistic pieces of data. Like atoms, they can't be divided in smaller parts and they got finished boundaries. And last but not least, you can *enumerate* them.

<img align='right' src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/bin1.png'/>
==Entrelacs / raw data equivalency==

The _arrows paradigm_ allows to compose arrows with atomistic row data as well.
It doesn't deny the _everything is arrow_ credo since all in all _entrelacs_ and _atomistic pieces of data_ are equivalent.

In other words, raw binary data corresponds to some sort of arrows as well. Mathematically, one says there's an isomorphism between the set of entrelacs and the set of natural numbers (ie. raw data).

Big notice: As any regular arrow, the EntrelacsSystem stores each piece of data in an "unique" and "immutable" way. For instance, one won't find more than one copy of "hello world" character string in the whole system storage space.




See AtomEntrelacEquivalency for further reading.

==Arrow connectivity and wording==
<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrow1.png'/></p>

Each arrow is an oriented pair of arrows.
  * the first arrow in the pair is named the "tail".
  * the last arrow in the pair is named the "head".
  * one says an arrow "goes out" its tail arrow.
  * one says an arrow "comes into" its head arrow.
  * from its tail point of view, an arrow is an "outgoing" arrow.
  * from its head point of view, an arrow is an "incoming" arrow.
  * each arrow may have many incoming and outgoing arrows. One calls them "children" arrows.
  * arrows reached by following head and tail links starting from a given arrow are called this arrow's "ancestors".

==rooted arrows==

The whole system knowledge might be represented with a single arrow whose definition would embed all known information.

But it's more convenient to represent the system top-level context as a set of distinct arrows.

Such arrow are call _rooted arrows_. They corresponds to regular arrows flagged with a "root" mark, that is a "root" boolean property added to the arrow definition within the system storage space.

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/rooted1.png'/><br/>some rooted arrow. Note the check mark (Lambda) notation.</p>

Arrows representation uniqueness induces rooted arrows may as well be ancestors of other rooted arrows. The system garbage collector can only reclaim storage resources of an arrow which is neither a rooted arrow nor an ancestor of any remaining rooted arrow.

==arrow assimilation and redundancy free storage=

At each system iteration, system inputs are converted into arrows before being processed. This conversion is called "assimilation".

"Assimilation" takes place at system boundaries. "Assimilation" converts textual representation of information (events, data, programs, commands, ...)  as arrows.

The "assimilation"  process ensure stored arrows uniqueness. Any definable arrow -whatever it is a regular pair or a binary datum- has to be represented only once in the whole system storage space.

==immutability==

<img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/average1.png' align='right'/>

As one arrow might be the ancestor of many other arrows, it can't be modified once stored in the system space.

Modifying an existing arrow definition within the knowledge system consists in rooting the new updated arrow then un-rooting the existing definition. This process wil recycle most of the arrow ancestors thanks to the arrow uniqueness rule of assimilation.

==arrows based knowledge representation==

To represent useful information with arrows, one can adapt many classical data models and even invent new ones. See ArrowModeling for further readings.