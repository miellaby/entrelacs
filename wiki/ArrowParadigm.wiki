#summary Everything is an arrow
#labels Featured

=Introduction=

The *Entrelacs Manifesto* proposes to follow the _*Entrelacs paradigm*_. It consists in modeling information in the form of _arrows_ made constructs.

==The arrow==
<img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrows1.png' align=right>   

_Arrows_ are the only information building block one needs for to store information.
 
An _arrow_ is:
  * _a pair of arrows_: both ends of an arrow are not _nodes_ but  *arrows* as well. *An arrow made structure consequently doesn't belong to [http://en.wikipedia.org/wiki/Graph_theory graph theory].*
  *  _oriented_: the pair (A,B) is distinct from (B,A). Please note this point is not so critical as one might build oriented arrows by combining non-oriented arrows. 
  * _unique_: There is only one arrow (A,B) from A to B, whatever A and B two formerly defined arrows. The _entrelacs paradigm_ proposes to enforce this uniqueness within the information system. Each mathematically definable arrow is mapped at most once into the information storage space. In other world, arrows are [http://en.wikipedia.org/wiki/Singleton_pattern Singletons]^W^.
  * _immutable_: An arrow is considered as a pure mathematical object. One can't "modify" a natural number like 2. It's the same thing for arrrows. One can't _modify_ them. But an _Entrelacs system_ may assimilate new arrows and dismiss old ones.
  * _connected_: Within a managed arrows structure, a certain arrow may be connected to many children arrows. One must easily be able to browse all these children as it forms _emerging information_. It's the basis of a new kind of system abilities.

==Arrow connectivity and wording==
<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrow1.png'/></p>

Each arrow is an oriented pair of arrows.
  * The first arrow is the _tail_.
  * The last arrow is the _head_.
  * Tail and head are _ends_.
  * An arrow _goes out_ its tail.
  * An arrow _comes into_ its head.
  * From its tail point of view, an arrow is an _outgoing_ arrow.
  * From its head point of view, an arrow is an _incoming_ arrow.
  * Incoming and outgoing arrows are _children_.
  * Children, children of children, and so on, are _descendants_.
  * Ends, ends of ends, and so on, are _ancestors_.

==_Entrelacs_==

An _entrelacs_ is a set of intricated arrows forming an unique discrete construct. It means:
  * any arrow from the set is the descendant/ancestor of all the other arrows of the set. In other words: whatever A & B two arrows from the set, A is a descendant/ancestor of B, and B is a descendant/ancestor of A.
  * one may characterize an entrelacs according to its topology, that is the number of arrows it contains and how these arrows are connected together.

One considers that *entrelacs which are isomorph are equal*.

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/eve.png   '/><br/>this entrelacs is named _Eve_ (Eve has no ancestor but itself)</p>

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/composed1.png'/><br/>an arrow from _yin-yang_ to _triskel_ (two distinct entrelacs)</p>

Entrelacs act as atomistic pieces of information. They got finished boundaries and one can't identify smaller isolated components in them. And last but not least, one can *enumerate* them! They are equivalent in all respects to [http://en.wikipedia.org/wiki/S-expression atoms in S-expression]^W^.

==Uniqueness==

<img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/average1.png' align='right'/>

Each definable arrow is considered unique.

==Immutability==

As one arrow might be the ancestor of many other arrows, it can't be modified once stored in the system space.

Modifying an existing arrow definition within the knowledge system consists in rooting the new updated arrow then un-rooting the existing definition. This process luckily recycles most of the arrow ancestors thanks to the arrow uniqueness rule of assimilation.

==Rooting==

The whole system knowledge might be represented with a single arrow whose definition would embed all known information.

But it's more convenient to represent the system top-level context as a set of distinct arrows.

Such arrow are call _rooted arrows_. They simply are regular arrows flagged with a "root" mark, that is a "root" mutable boolean property added to the arrow definition.

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/rooted1.png'/><br/>some rooted arrow. Note the check mark (Lambda) notation.</p>

Arrows uniqueness induces rooted arrows are likely ancestors of other  rooted arrows as well.

An Entrelacs system garbage collector simply needs to reclaim storage resources of arrows which are neither a rooted arrow nor an ancestor of any remaining rooted arrow.


==Assimilation process==

At each system iteration, system inputs (network events, user inputs, ...) are converted into arrows before being processed. This translation process is called "assimilation".

"Assimilation" ensures arrows uniqueness. Any definable arrow must correspond to a _singleton_. There can't be more than one copy in the whole system space.

"Assimilation" takes place at system boundaries. But it also deals with information produced by system processes, like when some software get a new number by adding two natural numbers.

==More complex objects==

Though the _arrows paradigm_ only deals with _arrows_, it may handle raw data -like binary strings- as well. The point is that raw data are equivalent to natural numbers, which may in turn be seen as _Entrelacs_ as introduced before.

<img align='right' src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/bin1.png'/>

So handling raw data within an arrows structure doesn't deny the _everything is an arrow_ credo since such _pieces of data_ correspond to arrows as well.

Mathematically, one says there is an *isomorphism* between the set of _entrelacs_ and the set of natural numbers.

More generally, the arrow paradigm may be extended to take into consideration more complex information building blocks, like _tuples_ or _bags_.

But these complex objects must be considered exactly in the same way as their arrow based equivalent constructs, especially in terms of uniqueness, and immutability, and connectivity.

For instance, by considering the "hello world" character string:
 * there can't be more than one copy of this string in the whole information space, 
 * this string may not be modified in place,
 * one may browse all the arrows connected to this string, i.e. its children arrows.

See EntrelacEquivalences for further reading.

==Knowledge representation with arrows==

To get useful information structures with arrows, one may adapt many classical models and even invent new ones. See ArrowModeling for further readings.

==Similarity with existing theories==
Arrows are somewhat similar to [http://en.wikipedia.org/wiki/Cons cons cells]^W^, also represented as [http://c2.com/cgi/wiki?DottedPair dotted pairs]^W^. However, the Arrow definition doesn't relay on atoms, even if atoms are eventually reconsidered as closed re-entrant cons structures.

In addition, the Entrelacs theory comprehends _cons structures_ as immutable and unique formal objects. The assimilation process described herein consequently perfoms [http://en.wikipedia.org/wiki/Hash_consing Hash consing]^W^ and arrows may be seen as _hashed cons_.

All in all, the Entrelacs proposal consists in hash consing information globally and transparently within an homoiconic information system. The system also manages arrows connectivity, making the information graph _browsable_.