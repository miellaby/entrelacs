#summary The Entrelacs first prototype stands as an HTTP/REST server


= Introduction =

The Entrelacs system prototype stands as an HTTP/REST server which publishes Entrelacs arrows as HTTP resources.

== Merging Entrelacs paradigm and RESTFUL modeling ==

=== Resources are URI, URI are resources, everything is arrow ===
Entrelacs homoiconicity leads to *merge URI and resources into a single concept*.
   * resources are actually URI.
   * URI are actually resources.
   * The only mutable property of such a resource is whether it's "rooted" in the system or not.

=== URI/URL format ===

   * Qualified URI
     One proposes to map every arrow to an unique fully qualified URI which encodes its whole definition, e.g. arrow:// is Eve.

   * Qualified URL
     For a given system, a qualified URI can be directly converted into a qualified URL, and vice versa. For exemple, Eve may corresponds to the URL: http://some.entrelacs.server:8008//

   * Temporary references
     A system may also return a temporary reference to some arrow as a temporary URL. Temporary URL are only valid within a client session. e.g. a big binary datum may be referred as http://some.entrelacs.server:8008//$12AE44

   * Partially qualified URL
     Compound arrows may also be queried and retrieved as mixed URL. Such an URL embeds both ancestors qualified URIs and temporary references.

Note:
       * A temporary reference is actually a textual representation of the ((session-uuid)->(target)) arrow internal address within the ArrowsSpace.


== HTTP methods mapping ==
 * PUT is for "root"
 * DELETE is for "unroot"
 * GET is for "getting" an arrow.
 * POST is for evaluating an EL expression on the server.

Note:
      * One doesn't really "get" an arrow. But one can use the HTTP GET method
         * to assimilate a qualified URI and get back a temporary reference (for further purpose).
         * to deconstruct a temporary reference. That is getting a fully or partially qualified URL.
         * to get the content of a blob arrow.

== HTTP request body ==

When the HTTP request body is not empty, the considered arrow is the arrow from the request URI to the request body.
    * the request body may be a file content if typed as is.
    * or it may be a qualified URI, a reference URL, or a mix.

For example, if the URI corresponds to (A->B) and the body to (C->D), then the actually requested resource is ((A->B)->(C->D))

=== Proxying by applying closure ===

The Entrelacs server also includes an HTTP client so one may define a closure to invoke an external resource. Think: programmable AJAX router.

=== COMET with handballer or comparable HTTP-Turn server===

By combining an Entrelacs server with a COMET-like server, one may easily hook a Javascript callback within a browser to a server side closure. Every time the closure is applied on server side, the Javascript callback is run on client side thanks to some HTTP-push messaging. See [http://code.google.com/p/handballer HandBaller] for such a lightweight HTTP-push server.

=== URI path syntax ===

The "arrow://" scheme identifies a fully qualified URI. The scheme won't be cited in examples bellow.

 * Tag arrows (short string) are directly converted into URI by following standard URL encoding rule.
{{{
 "Hello World" <==> Hello%20World
}}}

 * A Blob arrow is identified by its footprint (SHA) preceded by the $/ sequence. e.g.
{{{
    "Very ... long ... text" <==> $/some-footprint
}}}


 * Compound arrows URI are obtained by the non-commutative non-associative {{{/tail.head}}} syntactic construct.

{{{
   ("Says" "Hello World") <==> /Says.Hello%20World

   ((A B) (C D)) <==> //A.B./C.D
}}}

 * Some syntactic shortcut are tolerated.
   * Excessive dot component are considered as if a slash was missing next to the nearest previous slash.
   * dot before a slash are optional.
{{{
   A.B.C.D == /A.B.C.D == //A.B.C.D = ///A.B.C.D <==> (((A B) C) D)
   /A.B/C.D == /A.B./C.D == //A.B./C.D <==> ((A B) (C D))
   /A/B.C.D == /A.//B.C.D == (A ((B C) D))
   //A/B.C.D == //A./B.C.D == ((A (B C)) D)
}}}

 * An empty end corresponds to Eve
{{{
  /D == /D. <==> (D Eve)
  /.A <==>  (Eve A)
  //A..D <==> ((A Eve) D)
  //A./D <==> (A (D Eve))
}}}

=== Qualified URL ===

The straightforward way to build up an HTTP API valid URL from an arrow URI is:
{{{
   <system-base-url>/<arrow-path> <==> arrow://<arrow-path>
}}}

For example, the "/foo.bar" arrow might be get at http://some.entrelacs.server:8008//foo.bar

=== Temporary reference ===

The system may return short temporary URL as arrow references. These URL is are valid in the current user agent session.

Temporary reference format is:
{{{
   <system-base-url>/$.AEF03233
}}}

=== Partially qualified URL ===

The client or the server may embed references inside the URI path syntax.
 e.g.
{{{
   <system-base-url>///Some/Head/$.AEF03233 <==> (("Some" "Head") <arrow at .../$.AEF03233 URL>)
}}}

=== Response format ===
Server returns arrows.

By default, the server tries to return fully qualified URL.

Exception 1: But if the fully qualified URL exceeds a maximal size, the server may return a temporary reference.

Exception 2: When returned arrow is a blob.
  * HTTP redirection to the reference URL.
  * Response body is raw data.

This default behavior may be modified by providing the X-Level: request header.
 * 0: Always return a temporary reference
 * 1: return a pair of temporary references, if relevant, otherwise return a qualified URI.
 * 2: return a pair of pair of temporary references, if relevant.

Note: The Accept: header might be used. TBC.

Additionally, the Alternate-Location: response header always points to a reference URL.


== Dismissed proposals:

 * Option: several arrows gathered in response.
  * M3U file with corresponding mime type in response.
  * _note: why not a single compound arrow_

 * Special arrow for MIME-typed file.
  * ((mime-type "video/avi") $.XXXXXX) where $.XXXXXX points a blob.

 * option: GET may retrieve blob arrow by footprint
   * Warning: May be considered as a security hole. TODO: the server asks for random range(s) of the file to check the client actually owns a copy of the blob.

 * option: GET is equivalent to POST, minus no body.
   * One simply evaluates the provided arrow as EL code.

 * option: pattern matching
   * May be explicitly asked by submitting (match (some pattern)) EL code.
   * or GET may be for pattern matching only. See algorithm bellow. If pattern contains no jokers, GET pattern is equivalent to arrow fetching.

 * option: operator "invoke". it applies the arrow head to any closure matching the arrow tail. This operator call the current continuation for every matching arrow. The server provides a default continuation which output arrows in a buffer. Once evaluation is done, the buffer sent back the response.



=== pattern matching ===
The pattern matching algorithm deals with an arrow made pattern and a closure. It calls the closure for any matching *rooted* arrow.

{{{
  HTTP GET /D <==> (D Eve) returns any arrow x where (D x) is rooted.
  HTTP GET //A./D <==> (A (D Eve)) returns any arrow x where (A (D x)) rooted.
  HTTP GET /A//./D <==> (A (Eve (D Eve))) return any arrow x of the form x = (y (D z)) where (A x) rooted.
}}}

=== POST method ===

POST is for arrow evaluation.

One simply evaluates the requested arrow, considered as the link from the URI-arrow to the body-arrow. The URI-arrow sub-expression must be evaluated as a closure. The URI-arrow might be a '/match/some/stuff' URI. TBC: If there is several matches, the operator will call the same continuation for each arrow.

option: when posting an arrow via the HTTP POST method, the server firstly matches one or several arrows corresponding to the URI string via the pattern matching algorithm above. TBC.

POST makes the EntrelacsMachine evaluate the application of the HTTP request body to the HTTP request URI. When several arrows are matched, well...

   * The server returns one URI or a collection of URI as a M3U file (TODO: better format).

=== Agent confining ===

*draft*

The default session might be confined to a session-attached sub context C such as HTTP PUT some-arrow would actually root C->some-arrow. HTTP GET/POST would not match global arrows. A HTTP login operator might help escape from the confined environment (killing the current session, unrooting anything attached, then creating a new session within the wider environment).

=== match operator and closure registering hierarchy ===

*draft*

Actually, when no closure matches the requested arrow, the pattern matching algorithm would descend into URI path hierarchy and seek for a matching closure.
{{{
Says the scenario
 match((a (b c))) :
 a is not a closure litteral.
 but if (a (b *)) matches a closure. One applies 'c' to it.
 otherwise, if (a *) matches a closure. One applies (b c) to it.
}}}