#summary The Entrelacs first prototype stands as an HTTP/REST server.

= Introduction =

The Entrelacs system prototype stands as an HTTP/REST server which publishes Entrelacs arrows as HTTP resources.

== Merging Entrelacs paradigm and RESTFUL modeling ==

 * Entrelacs homoiconicity leads to *merge URI and resources into a single concept*. Entrelacs resources are actually URI.
 * Regular arrows are compounded URI which contains enough information to deduce both ends URI.
 * For every returned arrow, the server may also returns a temporary alternative location/URL. This URL is valid for a given HTTP client session.
   * It is actually a representation of the ((session-uuid)->(target)) internal address.
 * Root/unroot operators are naturally mapped to PUT/DELETE HTTP methods.
 * GET methods are naturally involved in arrows fetching (connectivy network browsing).
 * POST are naturally involved in function application. In short, it'a a way to run some code on server side.
 * When the HTTP request body is not empty, it is seen as an addition to the request URI. The resulting requested arrow is the pair between the request URI/arrow and the request body.
    * If the URI corresponds to (A->B) and the body to (C->D), then the actually requested resource is ((A->B)->(C->D))

== Proxying by applying closure ==

Entrelacs server also include an HTTP client. So it's super easy to define a closure which invoke an external resource.

For example, one might leverage on a Entrelacs server as a programmable AJAX router (HTTP reverse-proxy).

=== COMET with handballer or comparable HTTP-Turn server===

By combining an Entrelacs server with a COMET-like server, one may easily hook a Javascript callback within a browser to a server side closure. Every time the closure is applied on server side, the Javascript callback is run on client side thanks to some HTTP-push messaging. See [http://code.google.com/p/handballer HandBaller] for such a lightweight HTTP-push server.

=== URI syntax ===

 * "arrow://" scheme. The scheme won't be cited in examples bellow.

 * Tag arrows (short string) are directly converted into URI by following standard URL encoding rule.
{{{
 "Hello World" <==> Hello%20World
}}}

 * A Blob arrow is identified by its footprint (SHA) preceded by the $/ sequence. e.g.
{{{
    "Very ... long ... text" <==> $/some-footprint
}}}


 * Compound arrows URI are obtained by the non-commutative non-associative {{{/tail.head}}} syntactic construct.

{{{
   ("Says" "Hello World") <==> /Says.Hello%20World

   ((A B) (C D)) <==> //A.B./C.D
}}}

 * Some syntactic shortcut are tolerated.
   * Excessive dot component are considered as if a slash was missing next to the nearest previous slash.
   * dot before a slash are optional.
{{{
   A.B.C.D == /A.B.C.D == //A.B.C.D = ///A.B.C.D <==> (((A B) C) D)
   /A.B/C.D == /A.B./C.D == //A.B./C.D <==> ((A B) (C D))
   /A/B.C.D == /A.//B.C.D == (A ((B C) D))
   //A/B.C.D == //A./B.C.D == ((A (B C)) D)
}}}

 * An empty end corresponds to Eve
{{{
  /D == /D. <==> (D Eve)
  /.A <==>  (Eve A)
  //A..D <==> ((A Eve) D)
  //A./D <==> (A (D Eve))
}}}

=== Qualified URL ===

The straightforward way to build up an HTTP API valid URL from an arrow URI is:
{{{
   <system-base-url>/<arrow-path> <==> arrow://<arrow-path>
}}}

=== Short URL as alternative location ===

The system returns an alternate short URL for each completely defined arrow returned in HTTP response. Short URL is only valid in the current user agent session.

Format is:
{{{
   <system-base-url>/$.AEF03233
}}}

=== Mixing Short URL and qualified URL

It's possible to build up a valid API URL by mixing the short URL syntax and the URI path syntax. e.g.
{{{
   <system-base-url>///Some/Head/$.AEF03233 <==> ((Some Head) <arrow at .../$.AEF03233 URL>)
}}}

== HTTP/REST API ==
It's *a draft*.

=== Response format ===
 * When response is one arrow and its URI is too long.
  * HTTP Redirection to a session-valid URL if needed.
  * Response body is the URI.

 * When response is one arrow and its URI is short enough.
     * HTTP redirection to the qualified URI/URL if needed.
     * Response body is the URI
     * Alternate-Location header points the session-valid URL.

 * When several arrows gathered in response.
  * M3U mime type and file format.
  * URL are session-valid URL only.
      * Or URI. Accept Header may force returned syntax.
  * _note: why not a single compound arrow_

 * When arrow is a blob.
  * HTTP redirection to a session-valid URL.
  * Response body is raw data.

 * Special arrow for MIME-typed file.
  * ((mime-type "video/avi") $.XXXXXX) where $.XXXXXX points a blob.

=== Alternative URL ===
When returned?
 * Among M3U file
 * When explicitly requested,
 * As a redirection when URI representation is too long
 * As "Alternative Location"

=== GET method ===

 * option 1: GET is for one arrow fetching
   * from alternative URL
   * from blob footprints
   * from URI. Useless except for the short URL.

 * option 2: GET is more or less equivalent to POST, minus no body.
   * One simply evaluates the provided arrow as EL code.
   * Pattern matching is explicitly asked by submitting (match (some pattern)).
   * An other operator "invoke" applies the arrow head to any closure matching the arrow tail. This operator call the current continuation for every matching arrow. The server provides a default continuation which output arrows in a buffer. Once evaluation is done, the buffer sent back the response.

 * option 3: GET is for pattern matching only. See algorithm bellow. If pattern contains no jokers, GET pattern is equivalent to arrow fetching.


=== pattern matching ===
The pattern matching algorithm deals with an arrow made pattern and a closure. It calls the closure for any matching *rooted* arrow.

{{{
  HTTP GET /D <==> (D Eve) returns any arrow x where (D x) is rooted.
  HTTP GET //A./D <==> (A (D Eve)) returns any arrow x where (A (D x)) rooted.
  HTTP GET /A//./D <==> (A (Eve (D Eve))) return any arrow x of the form x = (y (D z)) where (A x) rooted.
}}}

=== POST method ===

 * option 1: POST is for arrow evaluation.
*draft*

when posting an arrow via the HTTP POST method, the server firstly matches one or several arrows corresponding to the URI string via the pattern matching algorithm above. Then, it makes the EntrelacsMachine evaluate the application of the HTTP request body to the resulting arrow. When several arrows are matched, well...

alternative: one simply evaluates the requested arrow, considered as the link from the URI-arrow to the body-arrow. The URI-arrow sub-expression must be evaluated as a closure. The URI-arrow might be a '/match/some/stuff' URI. If there is several matches, the operator will call the same continuation for each arrow.

=== Returned URI ===

*draft*

The server returns one URI or a collection of URI as a M3U file (TODO: better format).

When an URI length exceeds a certain max value, it is converted into a session-specific alternate URI.

The Accept: header might force this default behavior so to get only fully qualified URI or only internal short-lived URI.

=== Agent confining ===

*draft*

The default session might be confined to a session-attached sub context C such as HTTP PUT some-arrow would actually root C->some-arrow. HTTP GET/POST would not match global arrows. A HTTP login operator might help escape from the confined environment (killing the current session, unrooting anything attached, then creating a new session within the wider environment).

=== match operator and closure registering hierarchy ===

*draft*

Actually, when no closure matches the requested arrow, the pattern matching algorithm would descend into URI path hierarchy and seek for a matching closure.
{{{
Says the scenario
 match((a (b c))) :
 a is not a closure litteral.
 but if (a (b *)) matches a closure. One applies 'c' to it.
 otherwise, if (a *) matches a closure. One applies (b c) to it.
}}}