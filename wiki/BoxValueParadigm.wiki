#summary Box/Value paradigm

==Introduction to the problem==

A large part of computer sciences consists in studying  [http://en.wikipedia.org/wiki/Data_structure data structures]^W^.

But how do we map data structures onto a physical support in first place?

For example, let's consider a set of statistics organized in a [http://en.wikipedia.org/wiki/Tree_(data_structure) tree]^W^. How are we going to put this structure onto a computer RAM and drives, or even a piece of paper?

<img align=right src=http://entrelacs.googlecode.com/svn-history/r489/trunk/doc/pictures/box_paradigm.png/>

==The box/value framework==

The usual practice consists in dividing the storage space into boxes so to put values into. Boxes are often nested into each others, so that a given box and its value can be comprehended as a gathering of smaller boxes. Also one generally use some values to identify and locate existing boxes in the storage space.

One will call this habit the _box/value framework_, or the _box/value paradigm_. We could have named it the _box/value meta-structure_ as well, because it deals with the canonical structure used to represent every other structure components: vertices, edges, tables, indices, etc.

Within a computer, values are binary representation of natural numbers and every sort of information is eventually mapped to natural numbers, some of them being pointers, indices, or parts of box identifiers. By following this paradigm, we are typically going to map our tree into boxes, every box containing one tree node and references to child tree nodes.

<img align=right src='http://entrelacs.googlecode.com/svn-history/r489/trunk/doc/pictures/Writing.png'/>

==box/value paradigm = Writing==

But why doing so? Why programmers and scientists have so rarely looked for alternatives?

One may presume it's due to how _Speech_ and _Writing_ have forged our mind.

_Writing_ is all about building up a hierarchy of nested boxes -sentences, words...- starting from signs, like letters or ideograms.

See, textual units correspond to physical representation of concepts. And as information is serialized into sentences, word repetition is the norm. Luckily, some constructs reduce redundancy by pointing other parts of a same text and previously introduced concepts; They act like _pointers_ and _indices_ in computer data structures.

All in all, _Writing_ is the typical implementation of the box/value paradigm. This process is so deeply rooted in our mind that it forms a mental lock making side-thinking excessively difficult.

==box/value paradigm = graph theory==
 <img align=right src='http://entrelacs.googlecode.com/svn-history/r489/trunk/doc/pictures/Graphe.png'/>

The box/value paradigm is slightly related to [http://en.wikipedia.org/wiki/Glossary_of_graph_theory graph theory]^W^.

A _graph_ consists in two types of elements, namely _vertices_ and _edges_. So does the box/value paradigm: boxes are _vertices_ and values act as _edges_ linking these boxes to each others.

To say it clearly: *as long as an information model relays on a _graph_, it's the implementation of the _box/value_ paradigm.*

So every time a new technology improves the box/value system, such as [http://en.wikipedia.org/wiki/Triple_store triple stores], one must keep in mind that there's no paradigm shift. These technical improvements eventually don't solve most of the issues introduced herein.

==Issues with the box/value paradigm==

 * *Redundancy*

        The box/value paradigm leads to map the same atomic concept again on many places. And recursively, any gathering of concepts will also tend to be repeated ad nauseam.

        For example, if our data tree contains several references to the natural number 2, this number will be repeated as is in as many boxes. Tree branches based on the same couple of natural numbers will also be repeated again and again.

        Our habits make us think that such a redundancy is necessary. Actually, it's not. Quite the contrary, dispatching many representations of the same concept among the storage space prevents software to exhibit a lot of useful behaviors.

        The issue is not so about room sparing. It's all about all these jobs that one can't ask for a computer without designing first a very complex and very resource-costly piece of software.

        <u>Concrete example</u>: You can't ask for your computer where and how it makes use of a given PI number approximation, or some English word. Search engines -like those included in some desktop environments- form a very partial solution to this problem.

 * * Compartmentalization*

        The box/value paradigm leads to dispatch information into separated and heterogeneous storage spaces.

        A regular operating system gives you tools to browse the structure of boxes it is responsible for, typically its file systems. But the structure of these boxes -the files by themselves- will depend on the applications which manage them.

        So work data in volatile memory. Thus, neither a human or software agent can fully browse and operate the whole content of a computer. One can't neither build new information nor produce new behaviors by cross-cutting the information contained in all these closed boxes.

        <u>Concrete example</u>: A simple picture manager will manage user pictures in well-known folders. But it won't access pictures embedded in other applications, like those stored or archived by other picture managers or mail agents. Most of all, no software today can simply get an access to the RAM-based pictures at a given time, whatever the rights conferred by its user.

 * *duality*

        The box/value paradigm is fundamentally dual.

       _Boxes_ and _vertices_  on one side, _values_ and _edges_ on the other side.

       This fundamental duality propagates itself up to the relationships between computers and their users, by oddly separating programmers from regular users. This separation is so common that it happens to feel natural and necessary. And yet, its first effect is to severally curb computers abilities.

       <u>Concrete example</u>: programmers on one side, and end-users on the other side. Maybe fine for the software industry; but is it fine to you?

 * Lack of *plasticity*

        As values and boxes are most of the time gathered into larger boxes, the box/value way has a negative impact on information plasticity.

        Bringing changes to information continuously obliges to enlarge existing boxes, and shift data to get room. It leads programs to be excessively complex due to costly [http://en.wikipedia.org/wiki/Serialization serialization and deserialization]^W^ processes which aim to get back a bit of this lost plasticity.

        Despite these huge and costly efforts in software development, most information residing in a traditional computer system -the programs themselves in first place- can't be modified be a casual user to better fit his needs.

        <u>Concrete example</u>: you can't modify your preferred application in any other aspect than those anticipated by its developers.

 * *opacity*

         The box/value paradigm joins meaning to values according to the boxes values belongs to. In other words, when considering a value, one must take into consideration the location of its parent box in its grandparent box, and so on up to the underlying material.

         As said before, boxes boundaries are generally indistinguishable from the outside.  In many case, one can't even characterize the upper box containing a given value at a random place. This opacity prevents to recover the hierarchy of contexts which eventually gives meaning to a given value.

         <u>Concrete example</u>: Software can't be studied and modified without original source code and data buried in user files can't be browsed without software specially created to manage these data. Extracting information from _raw_ data out of any context is called data forensics and is more considered as a kind of hacking.

 * *directed browsing*

         A box/value based information storage only guarantees that information may be browsed in one direction: from the highest boxes to the lowest values. It can't be simply browsed in the opposite direction. A program typically can't fetch the references to a box.

        <u>Concrete example</u> In most file systems, there is no simple way to know which directories links to a given file. But What's worse is that many file references are regular strings -file names, file paths- in applications and users data and there is no efficient way to retrieve them.

 * *No meta*.

        With the box/value paradigm, a value may be a reference to a box -though there is no obvious way to know it- but it can't simply refer to _a given value in a given box_ concept, or _a small box in a bigger box_ concept.

        Such pieces of information can't be simply stored as is and it's probably the biggest issue with a box/value based software stack. It leads to make a computer based system unable to handle its own information at an higher _level of abstraction_, i.e. at a _meta level_.

        Sure, many popular applications claim they manage _meta-data_ on various things. But keep mind that they only consider only *one* level of meta. They won't allow you to manage meta-data attached to these meta-data.

        <u>Concrete example</u>: A regular file system won't tell you the time when access policy changed for a given file.

 * *No way to enrich information*.

        A box/value based storage doesn't offer simple ways to link existing boxes with additional side values.

        One may create a side box to store existing references, but these references keep on being broken as information evolves. Plus these side boxes won't be taken into account by primary information browsing tools.

        <u>Concrete example<u> Most photo suites will attach information to pictures by setting up a database based on original picture filenames. But these precious and tenuous link is easily broken by  renaming the original picture files. Whatever the operating system, a program can't get strong and reliable references to existing files so to attach information from the outside.

More generally, there's no way to know who refers to a given piece data so to ensure consistency when replacing it.

ArticleCompleteness: 70%