#summary The EntrelacsLanguage (EL) is specially designed to deal with arrows.
= The language =

== loading "current arrow" with ... ==
{{{
 42             tag "42"
 @AEFA00FA      a previously retrieved arrow identified by its internal ID
 "foo"          tag "foo"
 (some program) a closure
 t              the current arrow's tail
 h              the current arrow's head
 &              the arrow between the stack head and the current arrow
 M              the current state machine
     ->  Mhh       the current continuation
     ->  Mhth      the current program
     ->  Mhtt      the current stack
}}}

== Testing ==
{{{
 ~         sets current arrow to ( stack head ; current arrow ) linking arrow only if already stored, otherwise Eve
 ==        changes the current arrow to Eve if it isn't equal to stack head
 _         changes the current arrow to Eve if it isn't rooted
}}}

== arrows stacking ==
{{{
 <     adds current arrow to stack
 >     unstacks to current arrow
}}}

== continuation chaining ==
{{{
 :     adds current arrow to continuation chain (supposed to be closure but not necessary) 
 /     cut = replaces current continuation with next continuation
 ;     unchains next continuation without make it current
 ????  swaps current continuation with next continuation (TBC)
}}}

== branching ==
{{{
 ? cuts if current arrow is Eve
}}}

== continuation mapping ==
{{{
 i map/cc incomings of current arrow
 o map/cc outgoings ...
}}}

== syntaxic sugars ==
{{{
 'foo (then white space) <==> "foo"
 $foo (then white space) <==> 'foo o_?h
 , <==> < (stack)
 . <==> Mhh (current continuation)
}}}

= Examples =
The following examples are given in the form of unparsed program strings.

==  Basic browse ==
{{{
 "'foo" ==> "foo" arrow
 "'foo + 'bar &" ==> 'foo->'bar arrow
 "'foo o" ==> each arrow outgoing from 'foo'
 "'foo oh" ==> the head of each known arrow outgoing from 'foo'
 "'foo i_?t" ==> each x verifying (x->'foo') rooted
 "'foo i_?<t<'bar ==?>>" ==> each rooted arrow matching ('bar'->*)->'foo' pattern
 (plan by "foo" incoming children)
 "'bar o<o<'foo ==?>>" ==> ditto, plan by "bar" outgoing children
}}}

== Branching ==
{{{
 "('bar):'foo_?42/" ==> if 'foo' rooted then '42' else 'bar'
}}}

== Continuation chaining ==
{{{
 "(tt):'foo o_?t" ==>  cb w/ all x / (foo->(*->(*->(*->x)))) rooted
 "(t):'foo,'bar&;+42&" ==>  cb w/ ('foo'->42)
}}}

= factoids =

==EL source codes are first class citizen==

EL sources are made up of arrows within the ArrowsSpace.

To get the best benefits of this unique property, EL is designed in a way which makes source code directly in the form of traditional functional oriented programs after being translated in a _continuation passing style_ (CPS) Abstract Syntax Tree.

This makes EL goes a step further than classical _homoiconicity_. An EL program can:
  * access itself at source level,
  * modify itself
  * make these changes persistent.

It gives Entrelacs hosted applications the ability to be fully reflexive. That is:
   * the ability to access itself, aka introspection
   * the ability to modify itself, aka intercession

It makes Entrelacs an ideal platform for reflexive computing.

==ready for Memoization==

The language is also designed to make the design of a computation cache easier. This approach is called Memoization. This is an universally applicable strategy of optimization where most often used code patterns will hit the computation cache for ready-to-use results or _continuations_.

==related concepts ==
   * Combinatory Logic / Lambda Calculus / Rewriting rules based languages
   * CAeK abstract machine / Stack Machine / Continuation
   * http://en.wikipedia.org/wiki/Memoization
   * Query language Ã  la SQL