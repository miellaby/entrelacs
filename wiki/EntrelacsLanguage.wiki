#summary The EntrelacsLanguage (EL) is a language specially designed for the Entrelacs System.

= reflexivity =

In difference with any existing language, an EL source is directly made from the material the evaluator operates!

   Indeed, when stored into a working Entrelacs System, an EL source is made from arrows (as defined by the ArrowParadigm) brought by the ArrowsSpace. There is definitely no text files here. Such format may exist only as an importation/exportation format out of the system boundaries.

So an EL programs can access and modify themselves in a persistent way. It makes Entrelacs an ideal platform for reflexive computing.


= homoiconicity =

EL is a single class citizenship based language similar to Combinatory Logic Theorical Language. There is no separation between variable/symbol vs. literals/scalars. EL deals with arrows and only arrows.

This audacious choice makes easier to design a computation cache (Memoization concept). It leads to an interesting universally applicable strategy of optimization, as most often used code patterns will hit the computation cache for ready-to-use _continuations_.

= combinators =

When EL perfoms an "application", it recognises this set of combinatory pattern. Take into account some of these combinators are continuations, that is intermediate form of a  combinator which is partially applied.

   * head: t0.(t.h) H ==> t0.h ;
   * tail: t0.(t.h) T ==> t0.t ;
   * root: t.h _ ==> t.h ; if t.h is a rooted arrow
   * root: t.h _ ==> h ; if t.h is not rooted
   * cut: t.h / ==> h ; dismiss back tracks
   * outgoing: t.h out ==> t.o1.o2..o_n_ (every h outgoing arrow)
   * incoming: t.h in ==> t.i1.i2..i_n_ (every h incoming arrow)
   * pushCC: A.push ==> A ; push A (may be seen as a continuation)
   * popCC: X.pop ==> A ; pop the last pushed arrow (sort of call-cc)
   * forgettable: temp A ==> A ; switch off memoization
   * memoizable: perm A ==> A ; switch on memoization
   * K: A.K ==>  K'.A
      * K'.A x ==> A
   * S: (b.x).S ==> (b.x).S'
      * (b.x).S' y ==> (b.x).y.S''
      * (b.x).y.S'' z ==> b x.z ! y.z ! !
   * S variant: b.(S.x) ==> b.(S'.x)
         * b.(S'.x) y ==> b.(S''.(x.y))
         * b.(S''.(x.y)) z ==> b z.x ! z.y ! !
   * substitution: (b.A)^.x y -> b.A' ; where A' is a new arrow corresponding to A with x replaced by y in its definition and all (\ thing) pairs replaced by thing (if thing is 'x', it won't be substituted)
   * apply: A.B ! ==> apply B to A ; by default: arrows are like "quoted" Lisp things, you must explicitly tell when a intermediate result corresponds to an application, that is a pattern which has to be substituted according to existing combinator patterns.

Warning: brackets and dots are there only to help vizualize arrows pattern. They don't correspond to any additional arrow.

When an arrow doesn't match any combinator pattern bellow, it is taken as it is by the evaluator and is added to the current environment, that is a chain of arrows. When the apply operator is called like in "A.B!" B will be applied to each element in the A chain.

= evaluation principles =
   * an EL expression is an arrow
   * evaluate an expression consists in repeating until exhaustion
   * To continue...


EL evaluation iteration
   * (Context;Applicated Arrow)->Context.

= related concepts =
   * Combinatory Logic
   * Continuation
   * http://en.wikipedia.org/wiki/Memoization
   * Rewriting rules based languages.
   * Lambda Calculus, Functional Language, Lisp.
   * Inference engine languages (Prolog)
   * Query language (SQL)