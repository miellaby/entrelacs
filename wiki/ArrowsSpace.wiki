#summary The "Arrows Space" (AS) is the key component of an Entrelacs system.

== introduction ==
An _"Arrows Space"_ (AS) designates a device to store arrows structures by following the [ArrowParadigm Entrelacs Paradigm]. The AS is the key component of an _Entrelacs System_.

Please note one may simulate an Arrows Space with [PenAndPaperReferenceDesign a pen and a paper sheet] .

An AS might become a real computer hardware. If so, it would not necessarily be designed as a bank of buckets for binary words like all the other storage device so far.

But for the moment, we will study the AS as a simulated device, that is a piece of software leveraging on traditional volatile and mass memory hardware.

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/mem0.png'/><br/>AS artistic view.<br>Arrows are basically pairs of pointers||

== AS requirements summary ==
One requires from an AS

 * Orthogonal persistence
   The AS must leverage on all persistent and volatile physical memory levels and flatten them down to a single homogeneous space.

 * De-duplication
   The AS must ensure each mathematically definable arrow which may come  in is not stored more than once.

 * Full connectivity
   The AS must store enough connectivity data to allow efficient retrieving of the ends and the _children_ of any arrow.

 * Garbage collection relatively to a _root_ referential
   * The AS must manage the _root_ boolean property of every stored arrow. The set of _rooted_ arrows forms an unique absolute referential.
   * The AS must preserve rooted arrows and their ancestors from deletion, while arrows which are neither a rooted arrow nor an ancestor of a rooted arrow must be transparently removed from the storage.

 * Binary strings and other complex objects native support
   * The AS may allow raw data (binary strings) native storage.
   * The AS may allow tuples (ordered set of arrows) native storage.
   * Though such objects must be treated like their equivalent arrow made constructs (entrelacs) in terms of uniqueness, immutability, connectivity...

==API overview==
The ArrowSpaceInterface sums up the _arrows space_ behavior to traditional software developers.

== How to reach these goals within existing hardware ==
=== Prevent duplicates during arrows assimilation ===

The _Arrows Space_ is filled up by converting data into arrows. This conversion process is called _assimilation_. It takes place:
  * when data -like user inputs- come from the outside.
  * when some internal computation produces new arrows.

Each new arrow is assimilated from its farthest ancestors, that is _entrelacs_. One first assimilates entrelacs, then entrelacs' children arrows, then their grand children, and so on up to the overall assimilated arrow.

To ensure each mathematically definable arrow is stored at most once, the assimilation process may operate the whole mass storage device as a giant content-indexed open-addressed reentrant hash-table.

Main steps of an arrow _assimilation_
  # hashing the arrow definition to get a default location.
  # looking for the existing singleton at the default location.
  # putting the arrow definition here if missing.
  # managing conflicts through open addressing as seen hereafter.

=== Hash everything !===

The first step of arrow assimilation process consists in computing a default location where to probe the arrow singleton and store it if missing.

To do so, one computes an hash code from the considered arrow definition.
 * Concerning a regular arrow, since it's basically a pair of ends, one computes its default location by hashing its both ends addresses.
 * Concerning raw data, the AS should hash the whole object body.
    * For a very long binary object, a *cryptographic hash function* should be used to get both a default location and an unique signature
      * The signature is stored previously to the object body.
      * It avoids a full binary comparison to formally identify an already stored singleton.
      * A good cryptographic function will also avoid _data cluttering_.
    * For a short binary object, a simpler *checksum function* may be used.
       * As this checksum can't unambiguously identify a present singleton, one must fully comparing the singleton data with the assimilated object.

=== Solve conflicts by Open Addressing ===

Once truncated modulo the total mass storage space size, an hash code defines a valid default arrow location.

In case of conflict with existing unrelated arrows, one shifts this default location by some offset. If there's still a storage conflict, one shifts the location again, and so on.

Checking for an already stored singleton of an arrow consequently requires to search for the copy by starting from the arrow default location:
  * if one finds the expected arrow at the considered address ==> hit!
  * if one finds nothing ==> miss! The empty location may be used to store the missing arrow if asked.
  * if one finds something else, then one keeps on searching at a nearby location.

This approach is called [OpenAddressing open adressing] when applied to hash tables. The default location is also named an _open address_ and the search process of an existing arrow is called _probing_.


=== Perform Orthogonal Persistence ===

The AS stores arrows into a mass storage device. But it accedes to this device through a massive RAM-based cache. Almost all fast-access volatile memory resources of the hosting system may be used to cache arrows. This cache has be totally transparent and must flatten all the memory levels of a traditional platform into a single one.


== Anticipated prototype ==

All the strategies introduced above are applied to the currently designed [ArrowsSpacePrototype AS prototype]. See this page for more details.