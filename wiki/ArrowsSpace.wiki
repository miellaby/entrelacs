#summary The "Arrows Space" (AS) is the key component of an Entrelacs system.

== introduction ==
An _"Arrows Space"_ (AS) designates a device to store arrows structures by following the [ArrowParadigm Entrelacs Paradigm].

Applied to data computing, such a device may be:
 * either a simulated device on top of an existing regular mass storage device.
 * or a real computer hardware.
    * please note that in such an case, the arrows space would not necessary be a binary machine.

== _man powered_ version ==

One may simulate an _arrows space_ by hand with [PenAndPaperReferenceDesign a pen and a paper sheet].

== middleware version ==
A reasonable implementation of an AS consists in a piece of low-level software on top of existing volatile and mass storage devices within a traditional platform.

==Summary of the middleware version requirements==
One requires from an AS:
 * Orthogonal persistence
   The AS must leverage on all persistent and volatile physical memory levels and flatten them down to a single homogeneous space.
 * De-duplication
   The AS must ensure each mathematically definable arrow which may come in is not stored more than once.
 * Full connectivity
   The AS must store enough connectivity data to allow  the efficient retrieving of the ends and the _children_ of any arrow.
 * Garbage collection relatively to a _root_ referential
   * The AS must manage the _root_ boolean property of every stored arrow. The set of _rooted_ arrows forms an unique absolute referential.
   * The AS must preserve rooted arrows and their ancestors from deletion, while arrows which are neither a rooted arrow nor an ancestor of a rooted arrow must be transparently removed from the storage.
 * Binary strings and other complex objects native support
   * The AS should allow to natively store raw data (binary strings) as well. These objects must behave like their equivalent arrow made constructs (entrelacs).
   * The AS may allow to natively store tuples (ordered set of arrows). These objects must behave like equivalent arrow made constructs.

==Programing Overview==
The ArrowSpaceInterface sums up the _arrows space_ behavior to traditional software developers.

==More about the AS middleware==

===Orthogonal persistence===
The AS stores arrows into a mass storage device. But it accedes to this device through a massive RAM-based cache. Almost all fast-access volatile memory resources of the hosting system are used to cache arrows. This cache is totally transparent and flatten all the memory levels of traditional systems into a single one.

=== Deduplication through assimilation ===

The _Arrows Space_ is filled up by converting data into arrows. This conversion process is called _assimilation_. It takes place:
  * when data -like user inputs- come from the outside.
  * when some internal computation produces new arrows.

Each new arrow is assimilated from its farthest ancestors, that is _entrelacs_. One first assimilates entrelacs, then entrelacs' children arrows, then their grand children, and so on up to the overall assimilated arrow.

To ensure each mathematically definable arrow is stored at most once, the assimilation process should operates the whole mass storage device  as a giant content-indexed open-addressed hash-table.

Big steps of the assimilation process:
  # hashing every arrow definition to get a default location.
  # looking for an existing copy at the default location.
  # putting the arrow definition here if missing.
  # managing conflicts by shifting locations by some reproducible offsets. Note checking for an existing copy consequently requires probing.

=== Hash everything !===

The first step of an arrow assimilation process consists in computing a default location where to probe and store the arrow.

To do so, one computes an hash code from the considered arrow definition:

 * As a regular arrow is a pair of ends, one computes an hash code by combining its both ends addresses.
 * Regarding raw data, the AS should hash the whole object body.
    * For very long binary objects, a *cryptographic hash function* should be used to get both a default location and an unique signature to be attached beside the object body.
      * This signature avoids a full binary comparison when checking for a potential copy.
      * A good cryptographic function will also avoid _cluttering_.
    * For short binary objects, a simple *checksum function* may be used by assuming it's not too costly comparing the whole object data with every potential stored copy.

=== Open addressing ===

Once truncated modulo the total mass storage space size, an hash code defines a valid default arrow location.

In case of conflict with existing content, one must shift the default location of an arrow by some offset. That's why the search process of an existing arrow works as is:
  * if one finds the expected arrow at its default address ==> hit.
  * if one finds nothing ==> miss The empty location will be used to the missed arrow definition here if asked.
  * if one finds something else, then one looks at a nearby location by adding an offset to the probing address.

This approach is called [OpenAddressing open adressing] when applied to hash tables. The default location is also named an _open address_ and the search process of an existing arrow is called _probing_.

== Anticipated prototype ==

cf. ArrowsSpacePrototype