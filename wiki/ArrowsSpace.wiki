#summary The "Arrows Space" is a part of the EntrelacsSystem. It's an orthogonally persistent storage space for arrows where each mathematically definable arrow is stored once.

=Introduction=
The main characteristic of the EntrelacsSystem is to provide a single matrix where to store knowledge as arrows. This storage space is called the "Arrows Space" hereafter.

==Arrow types==

From a mathematical point of view, a regular arrow is a pair of arrows. From the "Arrows Space" point of view, one regular arrow is a pair of identifiers, each identifier pointing an on other arrow definition within the storage space.

Additionally, the "Arrows Space" can store atomistic binary objects. Such an object is equivalent in every aspect of its to a regular arrow (precisly some "prim entrelacs").

One distinguishes two types of binary arrows:
   * _BLOB_ arrows are large binary objects. They are indexed by a cryptographic unambiguous hash code like SHA2.
   * _TAG_ arrows are short C-like null-terminated strings. They are indexed by a prone to conflict simple checksum-like hash code. Thats' why tags comparison must be enforced by a char by char check.

==Orthogonal persistence==
Entrelacs System is "orthogonally persistent" regarding arrows storage. The "Arrows Space" ensures all handled arrows are transparently stored into a persistent memory (disk-like) device.

System dynamics occur inside successive short "micro-transactions" so that changes are "atomically" saved on a regular basis.

==The arrows bank==
The level 0 (disk) memory is operated as a single memory bank of cells.

Each individual "cell" can store one "reference", that is an other cell address. Cells are used to store both definitions and connectivity of all known arrows.

24/02/09: A currently studied alternative is the pair of identifiers storage cell. Some sort of well flagged collocation might be used to store heterogeneous data within a cell.

|| http://entrelacs.googlecode.com/svn/trunk/doc/pictures/mem0.png   ||Storage memory artistic view. Regular arrows are pairs of pointers linking parent arrows each other. Binary arrows are more or less long binary sequences.||

===Arrows storage===

The default location of an arrow is chosen by computing its hash code, namely _h_.
 * For atomistic arrows, _h_ is computed as a Checksum (_Tag_) or a Cryptographic hash function (_BLOB_).
 * For regular arrows, _h_ is computed by combining the _h_ of the arrow's tail and head.
 * The definitive arrow location may be shifted on conflict by following an OpenAddressing strategy.
 * The definitive arrow location becomes the arrow identifier, noted _i_ hereafter.

The definition of the arrow identified by 'i' it then stored as is:
  * tail @ i,
  * head @ i + open offset,
  * _H_ (combined with additional data) @ i + 2 open offset.

The _open offset_ is computed according to the DoubleHashing strategy.

This hash based location allows to search for an existing arrow from their embedded atoms without necessarily fetching every intermediate ancestor of its.

===Parent arrows index===

For each newly stored arrow _i_  outgoing for a _tail_ arrow and incoming into a _head_ arrow, the ArrowsSpace puts 2 back references (i.e. _i_) into two additional cells:
 * One _i_ "after" the _tail_ definition,
   * "after" means the location is computed with the DoubleHashing offset derived from _tail_ hash code.
 * One _i_ "before" the _head_ definition.
   * "before" means the location is computed with the opposite of the DoubleHashing offset derived from _head_ hash code.

These references stored near arrow definitions form an index to find connected arrows from a given head or queue.

===Cell flags===
As different kinds of reference may be put in one cell, cell contents are categorized by few bits called "cell flags" hereafter.

Here is a candidate flags list.
  * PAIR = non-rooted regular arrow definition first storage cell
  * ROOT = rooted regular arrow first storage cell
  * BLOB = BLOB first storage cell
  * TAG = TAG first storage cell
  * REMAIN = remaining part of an arrow definition. Such a cell complete a "pair", "root", "blob", "tag" cell.
  * CHILD = reference to a child incoming/outgoing arrow

23/02/09: A king Huffman code for cell flags is currently studied. It will free storage bits in most useful/frequent cases. e.g.
* code 1 =>REMAIN & the 7 bits left within the byte are used to store the "Offset factor".
* code 01=>PAIR & the 6 bits left stores the ref counter

23/02/09: An additional "SMALL" cell flag might be used to store some very short piece of data as an atomistic arrow in a single storage cell. Work in progress. SMALL, TAG and BLOB storage strategies might be transparently chosen by the arrow space algorithm from a commmon arrow creation API call.


==Arrow footprint==

Finally, here is the typical (no conflict) footprint of an arrow _i_ going out from a _tail_ arrow and incoming to an _head_ arrow, _i_ being itself connected with few incoming/outgoing arrows.
{{{
//  Cell# Flag   Content
// [...]
//  i-4o  0      0
// [...]
//  i-3o  IN     third incoming arrow id
// [...]
//  i-2o  IN     second incoming arrow id
// [...]
//  i-o   IN     first incoming arrow id
// [...]
//  i     PAIR   tail id
// [...]
//  i+o   REMAIN head id
// [...]
//  i+2o  REMAIN H | reference counter
// [...]
//  i+3o  OUT    first outgoing arrow id
// [...]
//  i+4o  OUT    second outgoing arrow id
// [...]
//  i+5o  OUT    third outgoing arrow id
// [...]
//  i+6o  0      0
// [...]
}}}

The offsets are computed according to the DoubleHashing and OpenAddressing strategies. Conflicting data may introduce additional shifts.

23/02/09: offsets used will be different for each cell content dispatching: PAIR, IN, OUT, REMAIN to avoid resonance phenomena as much as possible. Some misc candidate offsets:
 * offset def = h % p2 (p2 = second twin prim number)
 * offset remaining = swapBytes(h) % p2
 * offset IN = neg(h) % p2
 * offset OUT = neg(swapBytes(h)) % p2


23/02/09: Arrow definition must be located on 3 successive cells withing an open space because we can melt two definitions in an unambiguous way. When a free cell is not followed by 2 other free cells, one can't use it to store a new definition, it has to be filled up with stuffing value to preserve the search algorithm accuracy. In the other side, IN/OUT ids list might be melted with various other data within an open space.

23/02/09: The few last values of the "jump factor" might be reserved to encode the number of valid bytes within the last cell used to store a binary string.


==Open Addressing==

See OpenAddressing

==Arrows Sweeper==

The "Arrows Sweeper" is a kind of _garbage collector_ working in the Arrows Space. The "arrows sweeper" spares rooted arrows and all their "ancestors", while no more rooted nor referred arrows are threaten to deletion.

On this purpose, a reference counter is attached in cell # i+3o for every arrow _i_. This counter is incremented each time a new arrow is incoming/outgoing  from/to _i_. It is decremented when such an arrow is deleted by the "arrow sweeper" itself.

The Arrows Sweeper is an incremental GC which proceeds to-be-deleted arrows. This job is dispatched on many transactions to avoid CPU overhead. Arrows to proceed are unrooted arrow or arrow with a reference-counter back to zero.

Since arrows are not deleted immediately, they may be saved from deletion by being rooted or linked back. An additional check of deletion criteria is performed just before the actual deletion.

Note the reference counter definition range is quite short. When it reaches its maximal value, it can't change anymore. It means the corresponding arrow will never be deleted. (TBC)

Actually, there may be a difference between a deleted cell and an empty cell, because of the "open addressing" way to resolve conflicts. When deleted, a cell is loaded with a "stuffing" value which prevents the including "open block" to be cut.

==candidate hash functions==
For practical reasons, the hash function should be commutative on structure of pairs. To be done.

     * key hash = f(tail, head) = ((head << 24) & tail) % P0
     * drone hash = g(tail, head) = ((head << 24) & tail) % P1
        * where P0 and P1 are twin prims near mem0 size 2^24
     * BLOB hash = truncated SHA-2
     * TAG hash = simpler checksum, like in http://www.cse.yorku.ca/~oz/hash.html

==RAM cache==

When needed, arrows climb up to a level 1 (RAM) memory device. This memory is used as a fine-grained cache of level 0 cells. 
See ArrowsCache for further details.

==What about the atomistic arrows?==

Atomistic arrows (BLOB or TAG) are stored like any regular arrow directly into the arrows bank. Data are stored in the definition cell (hash-indexed) and its neighbours (as defined by the OpenAddressing strategy).

For BLOB, data are actually preceded by the full computed SHA-2 hash code, in order to immediately eliminate false positives.

Atomistic arrows bodies must not be mixed up as we might not find which cell belongs to which arrow after all. Some bits are used to store a offset factor within each binary cell. This factor is used to directly jump up to the next cell containing the remaining part of the binary string. It allows to jump over conflicting data located in nearest cells within the considered open space.

==Misc.==

cf. InProgress