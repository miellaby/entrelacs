#summary The "Arrows Space" is an orthogonally persistent storage space where each mathematically definable arrow is stored at most once.

== Introduction ==
The EntrelacsSystem aims to offer an arrows storage system, namely the "Arrows Space" (AS).

==Arrow categories==
The AS can store 3 types of data so far.
   * regular arrow,
   * blob,
   * tag.

=== regular arrow ===
A regular arrow is a pair of arrows. So regular arrows are stored as pairs of address, each address pointing to another arrow location in the AS.

=== blob & tag === 

Blobs and tags are atomistic binary objects. Such data are handled as regular arrows (as they are equivalent to "entrelacs").

==== Size difference ====
  * _Blobs_ are *large* binary objects.
  * _Tags_ are *short* C-like null-terminated strings.

Note: the choice of converting external data into either tags or blogs might be automatic.

==== Hash function difference ====
  * _Blobs_ hash codes are returned by a cryptographic unambiguous hash function (SHA)
  * _Tags_ hash codes are returned by a simple checksum-like hash function. They are only 16 bits long and are obviously prone to conflicts. When looking for an existing tag, one must complete the hash comparison with a char-by-char check.

== Orthogonal persistence ==
The AS is "orthogonally persistent". Arrows are transparently stored into mass memory (host disk).

== Mass memory architecture ==

The mass memory is structured as a single memory bank of _cells_.

A _cell_ is a storage unit. It can :
  * be identified by an unique address
  * can store one cell address.

Cells store everything in the AS:
  * arrows definition
  * arrows connectivity
  * blobs and tags content

Still studied: A cell could store a pair of address rather than a single address. Cells collocation could be managed by adequate flag bits.

<p align='middle'><img src='http://entrelacs.googlecode.com/svn/trunk/doc/pictures/mem0.png'/><br/>AS artistic view.<br>Arrows are either pairs of pointers to other arrows or binary raw data.||

== Arrows location ==

The default location of an arrow _f_ is returned by an hash function _h_.
 * arrow : _h_(f) = function(h(tail(f)), h(head(f))) 
 * tag : _h_(f) = checksum(content(f))
 * blob : _h_(f) = hash(content(f)) (a cryptographic hash function).

When hash conflict occurs, the location of a stored arrow _f_ may be shifted from _h(f)_ according to an OpenAddressing strategy. The definitive location of _f_ is also its AS internal identifier _i_.

The hash based default location allows to quickly search for existing arrows. The recursive definition of _h_ for a regular arrow allow to compute this location without even fetching every ancestor of the arrow.

== Arrows definition data ==

The definition of an arrow _f_ internally identified by 'i' is stored as is:
  * tail(f) at i,
  * head(f) at i + offset(f),
  * h(f) (combined with additional data) starting at i + 2 open offset.

_offset(f)_ is a variable offset. It is computed according to the DoubleHashing strategy.

== Connectivity data ==

For each newly stored arrow _i_  outgoing from a _tail_ arrow and incoming into a _head_ arrow, the AS puts:
  * _i_ in one cell "after" the _tail_ definition,
   * "after" means the location is computed with the DoubleHashing offset derived from _tail_ hash code.
  * _i_ in one cell "before" the _head_ definition.
   * "before" means the location is computed with the opposite of the DoubleHashing offset derived from _head_ hash code.

These back-references form an index to find connected arrows from a given head or a given queue.

===Cell flags===
As different kinds of data may be put in a single cell, cell contents are categorized by few bits called "cell flags" hereafter.

Here is a candidate flags list.
  * PAIR = non-rooted regular arrow definition first storage cell
  * ROOT = rooted regular arrow first storage cell
  * BLOB = BLOB first storage cell
  * TAG = TAG first storage cell
  * REMAIN = remaining part of an arrow definition. Such a cell complete a "pair", "root", "blob", "tag" cell.
  * CHILD = reference to a child incoming/outgoing arrow

23/02/09: A Huffman-style cell flags encoding is studied in order to spare bits, e.g.
  * code 1 =>REMAIN + the 7 remaining bits store an "Offset factor".
  * code 01=>PAIR + the 6 remaining bits store a "ref counter".

23/02/09: Still studied: An additional "SMALL" cell flag might be used to store some very short piece of data as an atomistic arrow in a single storage cell. Work in progress. 

==Arrow footprint==

Finally, here is the typical (no conflict) footprint of an arrow _f_ internally identified as _i_. _f_ goes out a _tail_ arrow and comes into an _head_ arrow. _f_ is also connected to several incoming or outgoing children arrows.
{{{
//  Cell# Flag   Content
// [...]
//  i-4o  0      0
// [...]
//  i-3o  IN     third incoming arrow id
// [...]
//  i-2o  IN     second incoming arrow id
// [...]
//  i-o   IN     first incoming arrow id
// [...]
//  i     PAIR   tail id
// [...]
//  i+o   REMAIN head id
// [...]
//  i+2o  REMAIN H | reference counter
// [...]
//  i+3o  OUT    first outgoing arrow id
// [...]
//  i+4o  OUT    second outgoing arrow id
// [...]
//  i+5o  OUT    third outgoing arrow id
// [...]
//  i+6o  0      0
// [...]
}}}

Conflicts data introduce shifts into this typical footprint. Offsets are computed according to the DoubleHashing and OpenAddressing strategies.
23/02/09: offsets used will be different for each cell content dispatching: PAIR, IN, OUT, REMAIN to avoid resonance phenomena as much as possible. Some misc candidate offsets:
 * offset def = h % p2 (p2 = second twin prim number)
 * offset remaining = swapBytes(h) % p2
 * offset IN = neg(h) % p2
 * offset OUT = neg(swapBytes(h)) % p2


23/02/09: Arrow definition must be located on 3 successive cells withing an open space because we can melt two definitions in an unambiguous way. When a free cell is not followed by 2 other free cells, one can't use it to store a new definition, it has to be filled up with stuffing value to preserve the search algorithm accuracy. In the other side, IN/OUT ids list might be melted with various other data within an open space.

23/02/09: The few last values of the "jump factor" might be reserved to encode the number of valid bytes within the last cell used to store a binary string.

==Open Addressing==

See OpenAddressing

== Garbage collector ==

The Garbage Collector must spare rooted arrows and all their "ancestors" and get back resources used by no more rooted nor referred arrows.

On this purpose, a reference counter is attached in cell # i+3o for every arrow _i_. This counter is incremented each time a new arrow is incoming/outgoing  from/to _i_. It is decremented when the arrow is deleted by the garbage collector. When a non-rooted arrow ref counter is equal to 0, one can recycle this arrow storage resources.

The GC proceeds to-be-deleted arrows in an incremental way. Its job is dispatched on many transactions to avoid CPU overhead. Since arrows are not deleted immediately, they may be saved from deletion by being rooted or linked back. An additional check of deletion criteria is performed just before the actual deletion.

Still studied: As the reference counter definition range is short. One postulates that when the counter max value is reached, one can't change it anymore. It means the corresponding arrow will never be deleted. (TBC)

Actually, there is a small difference between a deleted cell and an empty cell, because of the "open addressing" way to resolve conflicts. When deleted, a cell is loaded with a "stuffing" value which prevents the including "open block" to be cut.

==candidate hash functions==
For practical reasons, the hash function should be commutative on structure of pairs. To be done.

     * key hash = f(tail, head) = ((head << 24) & tail) % P0
     * drone hash = g(tail, head) = ((head << 24) & tail) % P1
        * where P0 and P1 are twin prims near mem0 size 2^24
     * BLOB hash = truncated SHA-2
     * TAG hash = simpler checksum, like in http://www.cse.yorku.ca/~oz/hash.html

==RAM cache==

When needed, arrows climb up to a level 1 (RAM) memory device. This memory is used as a fine-grained cache of level 0 cells. 
See ArrowsCache for further details.

==What about atomistic arrows?==

Atomistic arrows (BLOB or TAG) are stored like any regular arrow directly into the arrows bank. Data are stored in the definition cell (hash-indexed) and its neighbours (as defined by the OpenAddressing strategy).

Raw data are actually preceded by the full computed hash code, in order to immediately eliminate false positives.

Atomistic arrows bodies must not be mixed up as we might not find which cell belongs to which arrow after all. Some bits are used to store a offset factor within each binary cell. This factor is used to directly jump up to the next cell containing the remaining part of the binary string. It allows to jump over conflicting data located in nearest cells within the considered open space.

==Misc.==

cf. InProgress