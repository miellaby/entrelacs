#summary Introduction to Entrelacs design.

= Introduction =

This page gathers information about the way _Entrelacs_ works.

=The "Arrow paradigm"=
Entrelacs System deals only with "arrows". Its credo might be "Everything is an arrow".

==regular arrows==
An arrow is an unique immutable oriented pair of arrows.
  * "pair of arrows" means both ends of each arrow are two other arrows. ^An arrow graph doesn't contain any node.^
  * "oriented" means the pair (A,B) is different from (B,A).
  * "unique" means each identifiable arrow is stored only once in the whole storage space.
  * "immutable" means an arrow can't be modified once stored.

=="entrelacs"==
Each arrow definition embeds (leads to) a set of ancestor arrows forming a closed and connected interlaced pattern as a whole. Such a pattern is called an "entrelacs".

Moreover, some of these entrelacs are so reentrant they can't be divided into smaller ones. They are called "primary entrelacs" and may be seen as atomistic pieces of data.

Note that an arrow is equivalent in every aspect to the entrelacs formed by all its ancestors. We may substitute indifferently one to the other.

==atomistic arrows==
Entrelacs allows to store "unique" and "immutable" flat data as BLOB or TAG (C-String) scalars in addition to regular arrows.

Entrelacs underlying theory demonstrates such atomistic data are equivalent to primary entrelacs. In other mean, they are arrows as well. See AtomEntrelacEquivalency for further reading.

===vocabulary===
  * the first arrow in the pair (resp. the second) is named the "tail" (resp. the "head").
  * an arrow "goes out" its tail arrow and "comes into" its head arrow.
  * from its tail (resp. its head) point of view, an arrow is an outgoing (resp. incoming) arrow. Note an arrow may have many incoming/outgoing arrows.

====Rooted arrows===
All the system knowledge state might be represented as a single  interlaced pattern embedded in a unique arrow definition. However, it has been chosen for convenience to represent the system top-level context as a set of "rooted" arrows. Rooted arrows are regular arrows among the storage space simply flagged with a "root" mark.

==The Arrows Space==

Entrelacs System is "orthogonally persistent" regarding arrows storage. Its so called "Arrows Space" ensures arrows are transparently stored into a persistent memory (disk-like) device on a regular basis.

System dynamics occur inside successive short micro-transactions so that changes are "atomically" saved at each micro-transaction end.

The level 0 memory is designed as a single memory bank of cells which stores both definitions and connectivity data of all known arrows. Each individual "cell" can store one "reference", that is an other cell address.

The way to store arrows consists in placing information into location deduced from 2 hash codes:
  * the _arrow identifiers hash code_ (noted 'h') which combines both the arrow head and tail identifiers.
    * _h_ is the default location in the arrows space where to store the arrow definition. This location may be shifted to subsequent cells when a conflict occurs. The actual arrow location becomes the arrow identifier, noted 'i' hereafter.
  * the _arrow constructive hash code_ (noted 'H') which combines recursively both head and tail H.
    * _H_ is the default location to put an additional reference back to the arrow. These _H_ located references form an index which allows to reach an arrow from its embedded atoms without fetching every ancestors of its entrelacs.

A given arrow 'i' will be stored as is:
  * tail @ cell # i,
  * head @ cell # i+1,
  * _H_ @ cell # i+3 (combined with a reference counter).
And in addition
  * arrow back reference _i_ at cell # H (+ an offset depending on conflict).

Moreover, each time there is a new incoming (resp. outgoing) arrow 'j', we index 'j' identifier in the first free cell before (resp. after) the existing arrow definition at 'i'.

As different kind of references are present in cells, each reference has to be typed by a word of few bits (named its "flag" hereafter).
  * 0 0 0 0 = PAIR = first part of a regular arrow definition (ie. its tail id)
  * 0 0 0 1 = REMAINING = subsequent part of definition (head and more for a regular arrow)
  * 0 0 1 0 = INCOMING = reference an arrow whose head is an arrow defined in the following part of the block.
  * 0 0 1 1 = OUTGOING = reference an arrow whose tail is an arrow defined in the preceding part of the block.
  * 0 1 0 0 = INDEX = reference an arrow whose content-hash hits the preceding part of the block
  * 0 1 0 1 = BLOB = reference a BLOB (atomistish raw data) whose content-hash hits the preceding part of the block.
  * 0 1 1 0 = TAG = reference to a C-formatted string whose content-hash hits the preceding part of the block.
  * 0 1 1 1 = ROOTED_PAIR = a PAIR which belongs to a top-level root context.

Finally, here is the typical (no conflict) footprint of an arrow _i_ (where _i_ = h(tail,head)) with 3 incoming/outgoing arrows.
{{{
//  Cell# Flag   Content
// [...]
//  i-4   0      0
//  i-3   IN     Reference to a third incoming arrow (ie. whose head is arrow x)
//  i-2   IN     Reference to a second incoming arrow
//  i-1   IN     Reference to a first incoming arrow
//  i     PAIR   tail identifier
//  i+1   REMAIN head identifier
//  i+2   REMAIN H (constructive hash) | reference counter
//  i+3   OUT    Reference to a first outgoing arrow (i.e. whose queue is arrow x)
//  i+4   OUT    Reference to a second outgoing arrow
//  i+5   OUT    Reference to a third outgoing arrow
//  i+6   0      0
// [...]
//   H    IDX    i (arrow reference)
// [...]
}}}

Note: We study the possibility to insert an increasing stride between indexed incoming/outgoing arrows to avoid arrows bloat.

==Open Addressing==

When storing a new arrow, the cell pointed by 'h' (identifiers hash) may be already used. In such a case, one makes use of the "open addressing" trick.

This trick consists in managing conflicts by putting conflicting elements one after another, forming a contiguous memory block from the conflicting address up to the first free cell. Such a memory block will be called an "open block" hereafter.

So when the cell default location is already used, the definition data are shifted up to the next free cells.

==Arrows Sweeper==

The "Arrows Sweeper" is a kind of _garbage collector_ working in the Arrows Space. The "arrows sweeper" spares rooted arrows and all their "ancestors", while no more rooted nor referred arrows are threaten to deletion.

On this purpose, a reference counter is attached in cell # i+3 for every arrow _i_. This counter is incremented each time a new arrow is incoming/outgoing  from/to _i_. It is decremented when such an arrow is deleted by the "arrow sweeper" itself.

The Arrows Sweeper is an incremental GC which proceeds a FIFO of to-be-deleted arrows. This job is scheduled on many transactions to avoid CPU overhead. Arrows are added to this FIFO when unrooted or when their reference-counter go back to zero.

Since arrows are not deleted immediately, they may be saved from deletion by being rooted or refered back. An additional check is performed just before the actual deletion.

Note the reference counter definition range is quite short. When it reaches its maximal value, it can't change anymore. It means the corresponding arrow will never be deleted. (TBC)

Actually, there may be a difference between a deleted cell and an empty cell, because of the "open addressing" way to resolve conflicts in the Arrows Space. When deleted, a cell is loaded with a "stuffing" value which avoids an "open block" to be cut. It might be possible to move IN/OUT cells to stuff such an hole as well (TBC).

==RAM usage==

When needed, arrows climb up to a level 1 (RAM) memory device. This device is used as a fine-grained cache of level 0 cells. So it's an array of cell-containers (also called level 1 cells).

Each level 1 container stores:
  * one full level 0 cell,
  * its level 0 address,
  * its last usage transaction number. It is set when the cell is loaded and it is updated at each access. Level 1 cells are implicitly disposable when their related transaction numbers are old enough.

When climbing up to level 1, a cell is put preferably to level 0 address modulo cache size (yet an other hash). Conflicts management makes use of the "open addressing" trick as well. It means conflicting cells are putted one after an other.

Furthermore, all changes in level 1 cell contents are logged to prepare the saving process into level 0.

==Entrelacs Prim Language==

==Misc==
This section has to be dispatched in other wiki pages

Default hash functions
{{{
  * identifiers hash = h(tail,head) = 2 * head - tail
  * BLOB hash = truncated SHA (TBC).
  * TAG hash = simpler checksum.
}}}