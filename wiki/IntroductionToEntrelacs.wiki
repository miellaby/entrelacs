#summary An introduction to Entrelacs
#labels Featured,introduction

===stupid, stupid computers!===

Have you ever found software technologies disappointing? I consider on my own they are what mechanical engineering whould have been if nobody had ever invented the wheel.

It's due to a wrong manner of storing information that these technologies has followed since the very beginning: the _value in a box_ way.

This principle is derived from an aged invention named "writing", which also consists in putting signs to expected locations on some adequate support.  This principle is what human beings are accustomed to. It's so deeply buried in people's mind, it forms a mental lock which prevents programmers and theoreticians imagining something else.

And now, everything is built according to the _value in a box_ principle: operating systems, programming languages, data structures, and even the latest data formats like RDF.

And yet the _value in a box_ solution is terribly *limited*, simply because it can't accept "some value in some box" relation neither as a box nor as a value. That's what makes computers unable to abstract or elaborate any aspect of their knowledge. In other words, that's what makes computers stupid.

The EntrelacsSystem proposes to get ride of this weak "value in a box" way of thinking. Starting from now, one will build knowledge representation out of one and only one kind of building blocks: _arrows_.

===An arrow? what is it?===

In short, an arrow is... a pair of arrows.

Coders may think of it as a structure of 2 pointers linking such structures (C), a _con_ of cons (Lisp), a record in a twice reentrant relation table (SQL), an URI returning a pair of URI (web), etc.

But the arrow twice recursive definition is self-sufficient. The underlying theory features homoiconicity, meaning that contrary to graphs studied in academic institutions, it doesn't depend on a concept duality like _vertices and edge_.

That's what makes arrow structures different. Old models don't fit. For example, language theory might see arrows as a formal grammar without terminal symbols, but what's the point?

===how can one get rid of vertices?===

_Entrelacs_ are intricate balls of arrows linked each others. For example, the arrow whose tail and head both links back itself forms a simple entrelacs named "Eve". One can build an infinity of entrelacs out of any number of arrows.

Entrelacs actually behave like _terms_. One can't find smaller structures within but one can still recognize them according to their topology (i.e. how arrows are linked each others).  For example, one can recognize Eve as the only arrow featuring : Eve's head = Eve's tail = Eve.

In other words, entrelacs are somewhat equivalent to things like symbols, literals and linear pieces of data. And vice-versa: the "Hello" string is equivalent to a specific entrelacs, while "world" is an other entrelacs. All in all, everything is an arrow.

When an arrow is not part of an entrelacs, it corresponds to a link between two things, either an entrelacs or a previously defined link. Such an arrow can be linked in turn by some other arrows, and so on. So we've got signs and regular arrows to link them together. It's more than enough to represent any form of knowledge.

===Meaning made explicit===

An arrow has no meaning by itself. But one may invent a programming language and its related abstract machine where a set of arrows gets a particular meaning.

In traditional systems, such a sign-to-meaning relationship would be out of system scope. But arrows based system can link arrows to some behaviour as additional arrows within an upper context. Resulting arrows can possibly be explained in turn. And so on.

===pure abstraction===

When an human being thinks about a concept (eg. PI), his brain can easily access all sorts of information about it, like when he makes use of it, what concepts are related, and so on.

On its own, any regular computer stores a bunch of PI copies either as a floating-point encoded value or a symbol string. But the more copies there are, the less chances this computer can handle "PI" as a pure concept and make reasoning about it, like knowing when it makes use of it.

Arrows based systems highly simplify this problematic by preventing such copies to exist. Here is the second key concept regarding arrows system: Each arrow can't be stored more than once in the whole system storage. For example, the arrow linking "hello" to "world" is unique both as a mathematical object and in the system storage.

The point is not so much to spare storage resources. The point is that now the system *can* access any information related to, says, "hello" and "world" strings linked together. It can interact with other systems and human beings about this "hello" and "world" arrow. It can handle it, find all its known meanings, and think of it as a pure concept, just like the human brain always does.

Now you may ask: "how can one run several applications within such a system if they all shares the same arrows?"

This is the third and last key concept of arrows. Arrows are _immutable_. It means that once an arrow is stored within the system, one can't change it any more. It eliminates any risk of side effects.

Arrows structures are consequently persistent. User interactions don't make the system modify existing structures. It creates new structures instead by reusing most of their material. File system authors call this principle "copy on write", but this expression doesn't fit well, because one never copies anything, and one writes a given arrow only once.

===what about the perfs?===

Now you might share some doubts about the overall system efficiency. You're right worring. Ensuring each arrow is stored only once is costly. It has to be checked in two cases.
  * When one imports some data from the outside.
  * When some internal process declares new arrows within the system.

The EntrelacsSystem proposal consists in transforming the whole computer storage space into a giant self-refered open-adressed hash table. For each considered arrow, one computes an hash from its definition and looks for an existing copy into memory at the hash-given location. If such a copy exists, one reuses it, otherelse one stores the arrow there. One store arrows in a constructive way. One first builds terms, then term pairs, then more complex arrows, and so on. Actually, it's quite simple, isn't it?

That being said, please note the EntrelacsSystem also features orthogonal persistency and garbage collecting. These buzzwords mean that the system totally blurs the old computing space boundaries (you know... RAM, disk, files...) by offering a much more convenient and consistent working space where every agent is alive and every piece of information is saved on the fly. The nice part of it is that arrows based storage makes these properties really easy to design.

===how an arrow system really look likes?===

It's time to put the stress on what the system knowledge looks like as a whole. As a matter of facts, the whole system knowledge might be seen as a single giant structure of arrows totally contained in a single unique arrow definition. You read well: the whole knowledge of the system at a given actually consists in only one arrow whose all the ancestors form the knowledge as a whole.

However this theoretical view is not very handy. A simpler solution consists in adding a boolean flag to each arrow definition, telling whether the arrow belongs to a root context or not. This flag is the only modifiable property within the arrow definition.
* When set, the arrow and all its ancestors are stored into disk and are spared from the garbage collector process.
* When unset, the corresponding arrow is recycled as soon as no other arrow refers it any more (reference counters are used on this purpose).

I guess at this step of this reading, you might still wonder what kind of programming language the EntrelacsSystem corresponds to.

As a matter of fact, one can adapt any existing language: It may be imperative or declarative, functional or object oriented, etc.

Please note as well that many abstract machines, corresponding to many languages and technologies, could be hosted simultaneously within a single system. Arrows allow to embed evaluation contexts each others in a very natural way.

As a matter of facts, creating Domain Specific Languages could be probably the best way to add knowledge into a working system. In other words, each application -even your favorite office application- might be viewed as a abstract machine processing inputs and computing outputs according to a particular language. This machine could be defined on a top of a virtual running machine, which could be in turn defined on top of a meta machine, and so on.

===arrows system vs. Lambda calculus and relatives===

The root context of an arrows evaluation stack needs for a primary language. How could it looks like? Lambda Calculus, Combinatory Logic?

The point is that arrows underlying theory doesn't compete with Lambda Calculus and other modeled computation machines. Quite the contrary, arrows storage is the ideal complement to purely functional systems.

On my own, I see the Entrelacs System as a fundamental theory of knowledge representation  while lambda calculus, combinatory logic, pattern matching... are fundamental theories of computation.

For the reasons explained before, language theoreticians have simply ignored so far the representation part of the whole model. That's why they often look so condescending with real world trends like object-oriented technologies or tagsonomies. These trends are actually partial attempts to enhance the representation solution.

That being said, I think the EntrelacsSystem is an ideal basis to invent a new language combining both a pure functional and relationist models. Such a language could leverage on arrows to get innovative properties like:
 * making even more language concepts first order objects: closures, continuations, partial evaluations, environments, continuation chains...
 * generalizing "memoization": that is offering a transparent computation cache for any intermediate and complete computations so to never repeat twice the same calculation.


===conclusion===

That's why I prefer to introduce the EntrelacsSystem as a new kind of computing environment rather than yet another data base manager. If you read me carefully, I think you may understand this point of view now.

Please contact me if you think you can contribute to this project. To be honest, I've no spare time for it at the moment being. I forecast it will be the same during these next years.

And yet, I do think one could design an arrows space prototype right now. On a more theoretical side, one still needs a convenient language as a primary abstract machine. I'm currently exploring how I could adapt a CaEK machine to make it "arrows friendly". If anybody out there finds this idea exciting, I'd be happy pass on the torch.