#summary An introduction to Entrelacs
#labels Featured,introduction
<img align="left" src="http://entrelacs.googlecode.com/svn/trunk/doc/pictures/car.png"/>
===stupid, stupid computers!===

Have you ever found software technologies disappointing? I consider on my own they are what mechanical engineering would have been if nobody had ever invented the wheel.

What's wrong? Mainly the way computers are used to store information: the _value in a box_ principle.
<img align="right" src="http://entrelacs.googlecode.com/svn/trunk/doc/pictures/box.png"/>

The  _value in a box_ principle is  what human beings are accustomed to, because it's a straightforward adaptation of this ancient technology named "writing", which also consists in putting signs to expected locations on some adequate support. That's why this principle is deeply buried in people's mind, forming a mental lock which prevents programmers and theoreticians imagining something else.

Now, everything computer-related is designed according to the _value in a box_ principle: operating systems, programming languages, data structures, and even recently created data formats like RDF.

And yet the _value in a box_ solution is terribly *limited*, simply because it can't accept "some value in some box" relation neither as a box nor as a value. That's what makes computers unable to abstract or elaborate any aspect of their knowledge. In short, that's what makes computers *stupid*.

The EntrelacsSystem proposes to get ride of this weak "value in a box" way of thinking. Starting from now, one will build knowledge representation out of one and only one kind of building blocks: _arrows_.

===arrow, what is it?===

<img align="right" src="http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrows1.png"/>
In short, an arrow is... a pair of arrows.

Coders may think of it as a structure of 2 pointers linking such structures (C), or as a _con_ of cons (Lisp), or as a record in a twice reentrant relation table (SQL), or as an URI returning a pair of URI (web), etc.

The arrow twice recursive definition is self-sufficient. One says the underlying theory features homoiconicity, meaning that, contrary to graphs studied in academic institutions, it doesn't depend on a concepts duality like _vertices vs.edges_.

That's what makes arrow structures different. Usual models don't fit them. For example, one might consider arrows from language theory point of view and describe them as a formal grammar without terminal symbols. And so?

<img align="right" src="http://entrelacs.googlecode.com/svn/trunk/doc/pictures/eve.png"/>

===how can one get rid of vertices?===

_Entrelacs_ are intricate balls of arrows linked each others. For example, the arrow whose tail and head both get back to itself forms a simple entrelacs. One can build an infinity of entrelacs out of any number of arrows.

Entrelacs are interesting reentrant structures.
  * One can't isolate smaller structures within.
  * but one can still recognize them according to their topology (i.e. how arrows are linked each others). For example, one can recognize and name "Eve" this entrelacs whose single arrow features : Eve's head = Eve's tail = Eve.

In other words, entrelacs are somewhat equivalent to terms. They behave like symbols, literals and raw data. And vice-versa: the "Hello" string is equivalent to a specific entrelacs, while "world" is an other entrelacs. All in all, everything is an arrow.

When an arrow is not part of an entrelacs, it's a link between two things, either an entrelacs or another link. Such an arrow can be linked in turn by some other arrows in a constructive manner. 

===when meaning is made explicit in meta-context===

Entrelacs (signs) and regular arrows (to link signs together) are more than enough to represent any form of knowledge.

But arrows has no default meaning. Meaning depends on the observer's point of view.

Now, let's suppose one defines a new programming language where Eve gets a particular meaning.

In a traditional system, such a sign-to-meaning relationship would be hardcoded in an interpreter or a compiler. It would consequently stay out of system scope.

But in an arrow based system, arrow-to-meaning relationship is made explicit. It takes the form of additional arrows within an upper context. In this example, the new programming language would be interpreted by an abstract machine whose behaviour would be defined as well as arrows. The meaning of these arrows could possibly be explained in turn. And so on up to a primary machine.

The primary machine is actually the only machine whose behavior description resides out of the system scope. It could even be hardware based.

===arrows as pure concepts===

What can an human being do when he thinks about a concept like the pi number? Well, his brain can easily access all sorts of known information about it, like when and how it is used, what concepts are related to it, and so on. By digging into his memory, the brain can remember even more personal memories. For example, a mathematician would probably remember the first teacher who told him about pi.

In the same time, a regular computer stores plenty of "pi" copies -either its approximative value or its textual symbol- in various "boxes" but it can't make any reasoning about pi as a pure concept.

Comics caption:
 * _Hey computer! Can you tell me when you make use of pi and what approximations you use?_
 * bzz bzz.....!
 * _Come on, computer! I just want you to use more decimals next time._
 * bzzzzzz...

To make computers more useful, an arrows based system forbids duplicates. It ensures each mathematically definable arrow, like _Eve_ or the arrow from "hello" to "world", is mapped to at most one physical copy in the whole storage space.

The point is not so much to spare storage space. The goal is to make the computer as capable as an human being. One wants the system being able to recognize as an unique object the "hello" and "world" link every time he handles it, then being able to find all the known information about this object.

Now you may ask: "What happens when one changes an arrow copy which is involved in many contexts of knowledge and behavior?"

The response is that you can't change an arrow once it's physically put in the storage space. This is another key concept of such a system: Stored arrows are _immutable_.

Arrows structures are consequently _persistent_. It means the user interactions don't alter existing structures but creates new structures nearby. Hopefully, most of the existing material will be reused to build new structures, since arrows are never duplicated. 

The idea could be compared with the "copy on write" feature of disk file system, except that one doesn't write over anything nor make a copy of anything.


===use the whole computer storage space as a unique, giant, reentrant hash table===

Do you doubt about the overall EntrelacsSystem efficiency? You're right worring. Ensuring each arrow is stored only once is costly. It's part of a process called "arrow assimilation" which happens when:
  * data -like user inputs- come from the outside.
  * computation produces new arrows inside.

To do so, the system uses the whole computer storage space (hard disks) as a giant content-indexed self-referred open-adressed hash table.

Each new arrow is assimilated by starting from its farthest ancestors, ie. entrelacs. One first assimilates entrelacs, then pairs, then pairs of pairs, and so on up to the overall arrow. 

Assimilating an entrelacs simply consists in deducing its location within the table. To do so, one makes an hash code of its whole content definition (a cryptographic hashing function or a basic checksum may be used depending on the data size).

If the obtained location already contains the entrelacs, then one's found it. If the location is already used by an other arrow (hash codes can lead to conflicts), one simply shifts the location nearby (that's called OpenAddressing).
 
Assimilating regular arrows is as simple:
  * one computes an hash code from the tail and head both locations.
  * one looks at the obtained location.
    * If the arrow definition is found there, there's nothing more to do,
    * If something else is found, one shifts the location nearby
    * otherwise, one stores the arrow definition right there.

The so-called _arrows space_ also features orthogonal persistency. This buzzword means that the system behavior blurs the old computing space boundaries; you know: RAM, disk, files... The Arrows space as a whole forms a convenient and consistent work space where every agent is alive and every piece of information is saved on the fly.

===rooting and recycling knowledge===

The whole system knowledge at a given time might be contained in a single unique arrow definition. However this theoretical approach may not be so handy.

The preferred solution consists in adding a "root flag" to each stored arrow. This boolean value determines whether the arrow belongs to the _system root context_ or not. This flag may change during the system life time. It is actually the only modifiable property of already stored arrows.

This root flag is essential to the incremental garbage collector algorithm of the EntrelacsSystem. Considering a stored arrow:
  * When its flag is set, this arrow and all its ancestors are spared by the garbage collector.
  * When unset, corresponding resources can be recycled if no external arrow refers it any more (reference counters are used on this purpose).

===arrows as a language===

I guess at this step of this reading, you might still wonder what kind of programming languages the EntrelacsSystem corresponds to.

As a matter of fact, one can adapt any language of any kind: imperative or declarative, functional or object oriented, etc.

Please note as well that many abstract (understand software) machines, corresponding to many languages and technologies, could be hosted simultaneously within a single system. Arrows allow to embed evaluation contexts in each others in a very natural way.

As a matter of fact, creating Domain Specific Languages could be the best way to add new behaviors to the system. In other words, each application -even your favorite office application- might be designed as an abstract machine processing user inputs and computing some outputs according to a particular language.

Such a machine could be defined on a top of another higher level abstract machine, which could be in turn defined on top of a even higher machine, and so on up to a primary machine.

===arrows system vs. Lambda calculus and relatives===

The root context of an arrows evaluation stack needs for a primary language evaluated by a primary machine. How could it looks like: Lambda calculus, combinatory logic?

The point is that arrows underlying theory doesn't compete with Lambda Calculus and other modeled computation machines. Quite the contrary, arrows storage is the ideal complement to purely functional languages.

On my own, I consider the arrows theory as a fundamental theory of knowledge representation  while lambda calculus (and combinatory logic, and pattern matching...) are fundamental theories of computation.

Because of the mental lock I told you about, language theoreticians have ignored the knowledge representation problem. That explains why they are condescending with real world trends like object-oriented modeling or tagsonomies. Those trends are actually naive attempts to enhance the way one stores information in a computer.

That being said, I think the EntrelacsSystem is an ideal basis to invent a new language combining both a purely functional and a purely relationist theory. Such a language could leverage on arrows to get innovative properties. To name a few:
 * machine-level reflexivity: the whole machine state could be acceded by programs as a first order object. It would include closures, continuations chains, partial evaluations, environments, etc.
 * transparent "memoization": A cache of any intermediate computed results would automatically prevent repeating twice the same computation.
 * merged source code, CST and AST constructs: A single arrows based construct replaces them all.
 * persistent reflexivity: programs can make persistent changes into themselves.

===conclusion===

In conclusion, the EntrelacsSystem is not only a new way to store information within a computer. It's a plain new computing environment.

Please contact me if you like to contribute to this project. There's a lot of work.
 * I guess one could design an arrows space prototype rapidly.
 * In parallel, one should choose or invent a convenient language as a primary abstract machine. I'm currently exploring how I could adapt a CaEK machine. If anybody finds this idea exciting, I'd be happy pass on the torch.