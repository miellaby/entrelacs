#summary An introduction to Entrelacs
#labels Featured,introduction
<img align="left" src="http://entrelacs.googlecode.com/svn/trunk/doc/pictures/car.png"/>
===stupid, stupid computers!===

Have you ever found software technologies disappointing? I consider on my own they are what mechanical engineering would have been if nobody had ever invented the wheel.

What's wrong? Mainly the way computers are used to store information: the _value in a box_ principle.
<img align="right" src="http://entrelacs.googlecode.com/svn/trunk/doc/pictures/box.png"/>

The  _value in a box_ principle is  what human beings are accustomed to, because it's the straightforward adaptation of an ancient technology named "writing", which also consists in putting signs to expected locations on some adequate support. That's why it's so deeply buried in people's mind, forming a mental lock which prevents programmers and theoreticians imagining something else.

Now, everything computer-related is designed according to the _value in a box_ principle: operating systems, programming languages, data structures, and even recently created data formats like RDF.

And yet the _value in a box_ solution is terribly *limited*, simply because it can't accept "some value in some box" relation neither as a box nor as a value. That's what makes computers unable to abstract or elaborate any aspect of their knowledge. In other words, that's what makes computers *stupid*.

The EntrelacsSystem proposes to get ride of this weak "value in a box" way of thinking. Starting from now, one will build knowledge representation out of one and only one kind of building blocks: _arrows_.

===arrow, what is it?===

<img align="right" src="http://entrelacs.googlecode.com/svn/trunk/doc/pictures/arrows1.png"/>
In short, an arrow is... a pair of arrows.

Coders may think of it as a structure of 2 pointers linking such structures (C), or as a _con_ of cons (Lisp), or as a record in a twice reentrant relation table (SQL), or as an URI returning a pair of URI (web), etc.

The arrow twice recursive definition is self-sufficient. One says the underlying theory features homoiconicity, meaning that, contrary to graphs studied in academic institutions, it doesn't depend on a concepts duality like _vertices vs.edges_.

That's what makes arrow structures different. Old models don't fit. For example, language theory might consider arrows as a formal grammar without terminal symbols, but what's the point?

<img align="right" src="http://entrelacs.googlecode.com/svn/trunk/doc/pictures/eve.png"/>

===how can one get rid of vertices?===

_Entrelacs_ are intricate balls of arrows linked each others. For example, the arrow whose tail and head both get back to itself forms a simple entrelacs. One can build an infinity of entrelacs out of any number of arrows.

Entrelacs are interesting reentrant structures.
  * One can't isolate smaller structures within.
  * but one can still recognize them according to their topology (i.e. how arrows are linked each others). For example, one can recognize and name as "Eve" the entrelacs whose only arrow features : Eve's head = Eve's tail = Eve.

In other words, entrelacs are somewhat equivalent to terms. They behave like symbols, literals and raw data. And vice-versa: the "Hello" string is equivalent to a specific entrelacs, while "world" is an other entrelacs. All in all, everything is an arrow.

When an arrow is not part of an entrelacs, it corresponds to a link between two things, either an entrelacs or a previously defined link. Such an arrow can be linked in turn by some other arrows in a constructive manner. So we've got signs and regular arrows to link them together. It's more than enough to represent any form of knowledge.

===when meaning is made explicit in meta-context===

Arrows has no default meaning. Meaning depends on the observer's point of view.

Now, let's suppose one defines a new programming language where Eve gets a particular meaning.

In a traditional system, such a sign-to-meaning relationship would be hardcoded in an interpreter or a compiler. It would consequently stay out of system scope.

But in an arrow based system, arrow-to-meaning relationship is made explicit. It takes the form of additional arrows within an upper context. In this example, the new programming language would be interpreted by an abstract machine whose behaviour would be defined as well as arrows. The meaning of these arrows could possibly be explained in turn. And so on up to a primary machine. The primary machine would be the only machine whose behavior description resides out of the system scope.

===arrows as pure concepts===

What can an human being do when he thinks about a concept like the pi number? Well, his brain can easily access all sorts of known information about it, like when and how it is used, what concepts are related to it, and so on. By digging into his memory, the brain can remember even more personal memories. For example, a mathematician would probably remember the first teacher who told him about pi.

In the same time, a regular computer stores plenty of "pi" copies -either its approximative value or its textual symbol- in various "boxes" but it can't make any reasoning about pi as a pure concept.
 * _Hey computer! Can you tell me when you make use of pi and what approximations do you use?_
 * bzz bzz!
 * _Come on, computer! I just want to ask you to use more decimals next time._
 * bzzzzzz...

To make computers more useful, an arrows based system forbids duplicates. It ensures each mathematically definable arrow, like Eve or the arrow from "hello" to "world", is mapped to at most one physical copy in the whole storage space.

The point is not so much to spare storage space. The goal is to make the computer as capable as an human being. One wants the system being able to recognize as an unique object the "hello" and "world" link every time he handles it, then being able to find all the known information about this object.

Now you may ask: "What happens when one changes an arrow copy which is involved in many contexts of knowledge and behavior?"

The response is that you can't change a physical arrow once it's in the storage space.
This is another key concept of arrows based system: Stored arrows are _immutable_.

Arrows structures are naturally _persistent_. It means the user interactions don't alter existing structures but creates new structures. Hopefully, most of the existing material is reused to build these new structures, since arrows are never duplicated. 

The idea could be compared with the "copy on write" feature of disk file system, except that one doesn't write over anything nor make a copy of anything.


===use the whole computer memory as a single giant and reentrant hash table===

Do you doubt about the overall EntrelacsSystem efficiency? You're right worring. Ensuring each arrow is stored only once is costly. It has to be checked during a process called "arrow assimilation" which occurs when:
  * one imports information -like user inputs- from the outside.
  * some computation produces new arrows within the system.

To do so, the EntrelacsSystem architecture uses the whole computer storage space as a giant self-referred open-adressed hash table.

Each incoming arrow is assimilated by starting from its simplest components, that is its entrelacs. One first assimilates entrelacs, then pairs, then pairs of pairs, and so on up to the overall arrow. 

For each arrow to assimilate:
  * one computes an hash from the tail and head location (which were previously assimilated)
  * one looks for an existing copy into disk at the location given by the hash.
    * If such a copy exists, one reuses it,
    * else one stores the arrow there.

Isn't it simple?

That being said, please note the EntrelacsSystem also features orthogonal persistency. This buzzword means that the system totally blurs the old computing space boundaries; you know: RAM, disk, files...

The EntrelacsSystem proposes a much more convenient and consistent work space where every agent is alive and every piece of information is saved on the fly.

===rooting and recycling knowledge===

In theory, the whole system knowledge might be contained in a single unique arrow. However this theoretical approach is not very handy.

The chosen solution consists in adding a "root flag" to each stored arrow. This boolean value determines whether the arrow belongs to the _system root context_ or not. This flag can change during the system life time. It is actually the only modifiable property of already stored arrows.

This root flag is essential to the incremental garbage collector algorithm of the EntrelacsSystem. Considering a stored arrow:
  * When its flag is set, this arrow and all its ancestors are spared by the garbage collector.
  * When unset, corresponding resources can be recycled if no external arrow refers it any more (reference counters).

===arrows as a language===

I guess at this step of this reading, you might still wonder what kind of programming languages the EntrelacsSystem corresponds to.

As a matter of fact, one can adapt any language of any kind: imperative or declarative, functional or object oriented, etc.

Please note as well that many abstract machines, corresponding to many languages and technologies, could be hosted simultaneously within a single system. Arrows allow to embed evaluation contexts in each others in a very natural way.

As a matter of fact, creating Domain Specific Languages could be the best way to add new behaviors to the system. In other words, each application -even your favorite office application- might be designed as an abstract machine processing user inputs and computing some outputs according to a particular language.

Such a machine could be defined on a top of another higher level abstract machine, which could be in turn defined on top of a even higher machine, and so on up to a primary machine.

===arrows system vs. Lambda calculus and relatives===

The root context of an arrows evaluation stack needs for a primary language evaluated by a primary machine. How could it looks like: Lambda calculus, combinatory logic?

The point is that arrows underlying theory doesn't compete with Lambda Calculus and other modeled computation machines. Quite the contrary, arrows storage is the ideal complement to purely functional languages.

On my own, I consider the arrows theory as a fundamental theory of knowledge representation  while lambda calculus (and combinatory logic, pattern matching...) are fundamental theories of computation.

Because of the mental lock I told you about, language theoreticians have ignored the knowledge representation problem. That explains why they are condescending with real world trends like object-oriented modeling or tagsonomies, which are actually naive attempts to enhance the way one stores information in a computer.

That being said, I think the EntrelacsSystem is an ideal basis to invent a new language combining both a purely functional and a purely relationist theory. Such a language could leverage on arrows to get innovative properties like:
 * making even more language concepts first order objects: closures, continuations, partial evaluations, environments, continuation chains...
 * generalizing "memoization", ie. managing a cache of any intermediate computed results so to never repeat twice the same computation.

===conclusion===

In conclusion, the EntrelacsSystem is not only a new way to store information within a computer. It's a plain new computing environment.

Please contact me if you like to contribute to this project. There's a lot of work.
 * I guess one could design an arrows space prototype rapidly.
 * In parallel, one should choose or invent a convenient language as a primary abstract machine. I'm currently exploring how I could adapt a CaEK machine. If anybody finds this idea exciting, I'd be happy pass on the torch.