#summary An introduction to Entrelacs
Have you ever found current software technologies disappointing? On my own, I tell myself they look like what car industry would be if nobody invented the wheel. Something fundamental is still missing.

I've got an explanation. According to me, there is a mental lock in programmers and theoriticians' mind which prevents them to invent something really new, because the whole data computing industry is built upon a single design principle: the "value put in a box" way to store information. Nowadays, all data structure and computing systems are derived from it. Even the very last data formats like RDF are still under its sad influence.

However this approach is terribly wrong. It dooms abstraction and expressiveness. Considering a given value in a given box, a computing system can vaguely elaborate either on the box or its value but not on the "that value in that box" relation itself. Indeed, "a given value in a given box" information can't be directly used neither as a box nor as a value.

That's why I work on this new EntrelacsSystem. My proposal consists in reinventing data computing from scratch and getting ride of this weak "value in a box" way of thinking. I bet one can represent knowledge by using only one building block: the arrow.

The first point of the arrow definition is that an arrow is... a pair of arrows. If you're a C programmer, you might see an arrow as a pair of data pointers linking anything to anything, but this time, such a link can be used itself either as a referrer or a referred in other defined links.

Please note how the definition of an arrow is self-sufficient (it is recursive). One says the underlying maths feature homoiconicity because they're build upon only one concept. That's why arrows structure are so different than graphs seen in traditional courses. Just forget everything you learned or you could be afraid by considerations like "a formal grammar with no terminal symbols".

I'm convinced arrows are the only one building block I need to store any kind of information. How it could be?

Let's me introduce first you what I call "entrelacs".

"Entrelacs" are intricate balls of arrows linked each others. For example, the single arrow which refers itself both by its tail and its head forms an entrelacs by itself.

Please keep in mind this particular arrow. Further in the reading, I'll call it "Eve". By now, I postulate there is only one "Eve" arrow. Think about it as a pure mathematical object recognizable by this particular topology: eve.tail = eve.head = eve.

Entrelacs are very important. You can isolate them, recognize them, order them, enumerate them... As a matter of fact, entrelacs perfectly act as terms.

So one can build arrows out of terms like the "Hello" character string even if one only deals with arrows. Do you get the point? Terms are actually equivalent to much or less complex entrelacs, that is arrows. "Hello" is an arrow, "world" is another one. Everything is arrow. So one can consider arrows linking terms, like the arrow between "Hello" and "World" strings. Such arrows can be linked in turn by some other arrows, and so on.

At this step, we've got "signs" -thanks to entrelacs- and arrows to combine these signs in expressive structures. But signs are useless without a meaning. Hopefully, you can define a dictionary out of entrelacs. For example, you may decide that "Eve" (formerly introduced) corresponds to the zero digit. Then you may define a programming language based on this assumption.

However here is a major difference with traditional systems. With the "value in a box" paradigm, Meaning is most of the time "hard-coded". In other words, it lays out of the scope of the system.

On the other side, arrows based knowledge representation allows meaning to be defined according to a context that will be expressed by arrows as well. Those arrows can in turn get a meaning from an upper context. And so on.

Now, let's speak about the "PI" number. Are you agree how your brain can easily make an abstraction out of "PI" and elaborate out of it? On its own, a computer stores plenty of copies of the same PI values and symbols, and yet it can't handle "PI" as is, that is as a pure concept. It can't take decisions about it, access the knowledge it's got about it, know when it uses it, and such.

But arrows based computing does, because the second point of the definition of the arrow is that each arrow is uniquely defined both mathematically and within the system storage space. For example, the arrow linking "hello" to "world" is unique. It is also stored only once in the whole system memory.

The point is not so much to spare storage resources. The point is that now the system CAN access any information related to, says, "hello" and "world" strings linked together. It can interact with other systems and human beings about this "hello" and "world" arrow. It can handle it, found all the meanings of it, and elaborate on it as a concept, juste like the human brain always does.

Now you may ask: how can I could host several applications within such a system if they all shares the same arrows?

This is the third and last point of what an arrow is. Arrows are immutable. Once an arrow is stored within the system, you can't change it. So no risk of side effects.

Arrows structures are consequently persistent. When the end user interacts with the system, it doesn't modify these structures in place, it only create new structures by reusing most parts of the existing material. File system authors call this principle "copy on write", but this expression doesn't fit well, because one never copies anything, and one writes a given arrow only once.

Now you might share some doubts about the overall system efficiency. You're right worring. Ensuring each arrow is stored only once is costly. It has to be checked in two cases.
 * When one imports some data from the outside.
 * When some internal process declares new arrows within the system.

The EntrelacsSystem proposal consists in transforming the whole computer storage space into a giant self-refered open-adressed hash table. For each considered arrow, one computes an hash from its definition and looks for an existing copy into memory at the hash-given location. If such a copy exists, one reuses it, otherelse one stores the arrow there. One store arrows in a constructive way. One first builds terms, then term pairs, then more complex arrows, and so on. Actually, it's quite simple, isn't it?

That being said, please note the EntrelacsSystem also features orthogonal persistency and garbage collecting. These buzzwords mean that the system totally blurs the old computing space boundaries (you know... RAM, disk, files...) by offering a much more convenient and consistent working space where every agent is alive and every piece of information is saved on the fly. The nice part of it is that arrows based storage makes these properties really easy to design.

It's time to put the stress on what the system knowledge looks like as a whole. As a matter of facts, the whole system knowledge might be seen as a single giant structure of arrows totally contained in a single unique arrow definition. You read well: the whole knowledge of the system at a given actually consists in only one arrow whose all the ancestors form the knowledge as a whole.

However this theoretical view is not very handy. A simpler solution consists in adding a boolean flag to each arrow definition, telling whether the arrow belongs to a root context or not. This flag is the only modifiable property within the arrow definition. When set, the arrow and all its ancestors are stored into disk and are spared from the garbage collector process. When unset, the corresponding arrow is recycled as soon as no other arrow refers it any more (reference counters are used on this purpose).

I guess at this step of this reading, you might still wonder what kind of programming language the EntrelacsSystem corresponds to.

As a matter of fact, one can adapt any existing language to handle arrow structures. It may be some sort of imperative or declarative language. It may be functional, procedural or object oriented as well.

Please note as well that many abstract machines, corresponding to many languages and modeling technologies, could be hosted within a single system. Arrows allow to embed evaluation contexts each others in a very natural way. As a matter of facts, creating Domain Specific Languages could be probably the best way to add knowledge into a working system. In other words, each application -even your favorite office application- might be viewed as a abstract machine processing inputs and computing outputs according to a particular language. This machine could be defined on a top of a virtual running machine, which could be in turn defined on top of a meta machine, and so on.

However the root context of evaluation still needs for a primary language. How could it looks like? Lambda Calculus, Combinatory Logic?

The point is that the arrows underlying theory deals with information representation, while lambda calculus, combinatory logic or pattern matching are fundamental theories of computation.


Language theoreticians somewhat ignore the information representation part of the overall problem. That's why they often look a little bit condescending regarding real world trends like object-oriented technologies or tagsonomies. On my own, I see these trends as incomplete attempts to enhance the representation problem. A good language and its related runtime environment should combine the best of these two worlds.

That being said, I think the EntrelacsSystem is a basis to invent a new language from scratch. Such a language could leverage on arrows based storage to get innovative properties like:
 * making all internal aspects of the language first order objects: closures, continuations, partial evaluations, environments, continuation chains...
 * generalizing "memoization": that is offering a transparent computation cache for any intermediate and complete computations so to never repeat twice the same calculation.

That's why I prefer to introduce the EntrelacsSystem as a new kind of computing environment rather than yet another data base manager. If you read me carefully, I think you may understand this point of view now.

Please contact me if you'd like to contribute to this project. To be honest, I've no spare time at the moment being for this project. I forecast I won't be able to work much on it during these next years.

And yet, I do think one could design an arrows space prototype right now. On a more theoretical side, one still need a convenient language as a primary abstract machine. I'm currently exploring how I could adapt a CEK machine to make it arrows oriented. If anybody out there finds this idea exciting, I'd be happy pass on the torch.