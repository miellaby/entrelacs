#summary An introduction to Entrelacs
Have you ever found current software technologies disappointing? On my own, I tell myself they look like what car industry would be if nobody invented the wheel. Something fundamental is still missing.

I've got an explanation. According to me, there is a mental lock in programmers and theoricians' mind which prevents them to invent something really new, because the whole data computing industry is built upon a single design principle: the "value put in a box" way to store information. Nowadays, all data structure and computing systems are derived from it. Even the very last data formats like RDF are still under its sad influence.

However this approach is terribly wrong. It dooms abstraction and expressiveness. Considering a given value in a given box, a computing system can vaguely elaborate either on the box or its value but not on the "that value in that box" relation itself. Indeed, "a given value in a given box" information can't be directly used neither as a box nor as a value.

That's why I work on this new EntrelacsSystem. My proposal consists in reinventing data computing from scratch and getting ride of this weak "value in a box" way of thinking. I bet one can represent knowledge by using only one building block: the arrow.

The first point of the arrow definition is that an arrow is... a pair of arrows. If you're a C programmer, you might see an arrow as a pair of data pointers linking anything to anything, but this time, such a link can be used itself either as a referrer or a referred in other defined links.

Please note how the definition of an arrow is self-sufficient (it is recursive). One says the underlying maths feature homoiconicity because they're build upon only one concept. That's why arrows structure are so different than graphs seen in traditional courses. Just forget everything you learned or you could be afraid by considerations like "a formal grammar with no terminal symbols".

I'm convinced arrows are the only one building block I need to store any kind of information. How it could be?

Let's me introduce first you what I call "entrelacs".

"Entrelacs" are intricate balls of arrows linked each others. For example, the single arrow which refers itself both by its tail and its head forms an entrelacs by itself.

Please keep in mind this particular arrow. Further in the reading, I'll call it "Eve". By now, I postulate there is only one "Eve" arrow. Think about it as a pure mathematical object recognizable by this particular topology: eve.tail = eve.head = eve.

Entrelacs are very important. You can isolate them, recognize them, order them, enumerate them... As a matter of fact, entrelacs perfectly act as terms.

So one can build arrows out of terms like the "Hello" character string even if one only deals with arrows. Do you get the point? Terms are actually equivalent to much or less complex entrelacs, that is arrows. "Hello" is an arrow, "world" is another one. Everything is arrow. So one can consider arrows linking terms, like the arrow between "Hello" and "World" strings. Such arrows can be linked in turn by some other arrows, and so on.

At this step, we've got "signs" -thanks to entrelacs- and arrows to combine these signs in expressive structures. But signs are useless without a meaning. Hopefully, you can define a dictionary out of entrelacs. For example, you may decide that "Eve" (formerly introduced) corresponds to the zero digit. Then you may define a programming language based on this assumption.

However here is a major difference with traditional systems. With the "value in a box" paradigm, Meaning is most of the time "hard-coded". In other words, it lays out of the scope of the system.

On the other side, arrows based knowledge representation allows meaning to be defined according to a context that will be expressed by arrows as well. Those arrows can in turn get a meaning from an upper context. And so on.

Now, let's speak about the "PI" number. Are you agree how your brain can easily make an abstraction out of "PI" and elaborate out of it? On its own, a computer stores plenty of copies of the same PI values and symbols, and yet it can't handle "PI" as is, that is as a pure concept. It can't take decisions about it, access the knowledge it's got about it, know when it uses it, and such.

But arrows based computing does, because the second point of the definition of the arrow is that each arrow is uniquely defined both mathematically and within the system storage space. For example, the arrow linking "hello" to "world" is unique. It is also stored only once in the whole system memory.

The point is not so much to spare storage resources. The point is that now the system CAN access any information related to, says, "hello" and "world" strings linked together. It can interact with other systems and human beings about this "hello" and "world" arrow. It can handle it, found all the meanings of it, and elaborate on it as a concept, juste like the human brain always does.

Now you may ask: how can I could host several applications within such a system if they all shares the same arrows?

This is the third and last point of what an arrow is. Arrows are immutable. Once an arrow is stored within the system, you can't change it. So no risk of side effects.

Arrows structures are consequently persistent. When the end user interacts with the system, it doesn't modify these structures in place, it only create new structures by reusing most parts of the existing material. File system authors call this principle "copy on write", but this expression doesn't fit well, because one never copies anything, and one writes a given arrow only once.

Now you might share some doubts about the overall system efficiency. You're right worring. Ensuring each arrow is stored only once is costly. It has to be checked in two cases.
 * When one imports some data from the outside.
 * When some internal process declares new arrows within the system.

The EntrelacsSystem proposal consists in transforming the whole computer storage space into a giant self-refered open-adressed hash table. For each considered arrow, one computes an hash from its definition and looks for an existing copy into memory at the hash-given location. If such a copy exists, one reuses it, otherelse one stores the arrow there. One store arrows in a constructive way. One first builds terms, then term pairs, then more complex arrows, and so on. Actually, it's quite simple, isn't it?

That being said, the EntrelacsSystem features orthogonal persistency and garbage collecting. In other worlds, the system totally blurs the old computing space boundaries (you know: RAM, disk, files...) by offering a much more convenient and consistent knowledge space. The nice part of it is that arrows based storage makes these features really easy to design.

The main idea is to add a simple boolean flag to each arrow definition, telling whether the arrow belongs to a root context or not. This flag is the only modifiable property within the arrow definition. When set, the arrow and all its ancestors are stored into disk and are spared from the garbage collector process. When unset, the corresponding arrow will be recycled if no other arrow still refers it (reference counters are used).

I guess at this step of this reading, you might still wonder what kind of programming language the EntrelacsSystem corresponds to.

As a matter of fact, one can adapt any existing machine to handle arrow structures. It may be some sort of imperative or declarative language. It may be functional, procedural or object oriented. It's actually out of topic.

The point is that the arrows underlying theory is a theory of information representation, while lambda calculus, combinatory logic or pattern matching are fundamental theories of computation. A good language and its related runtime environment should combine the best of these two worlds.

Language searchers somewhat ignore the information representation part of the problem. That's why they often a little bit condescending regarding real world trends like object-oriented technologies or tagsonomies. On my own, I see these trends as an aborted path up to arrows paradigm.

That being said, I think it could be a good idea reinventing a new language from scratch as well. A new language could leverage on arrows based storage to get innovative properties like:
* making all internal aspects of the language first oder objects: continuations, partial evaluations, environments, call stack...
* generalizing memoization: that is a transparent computation cache for any intermediate and complete computations.



