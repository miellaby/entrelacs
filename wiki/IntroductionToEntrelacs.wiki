#summary An introduction to Entrelacs
#labels Featured

==stupid, stupid computers==

Have you ever found software technologies disappointing? They look to me what car industry would be if nobody had invented the wheel. They lack for something fundamental.

It's due to the wrong path IT technologies have taken many years ago: the _value put in a box_ way to store information.

Now, the whole data computing industry is built upon this design approach. All data structures and computing systems are derived from it. Even the most recent data formats like RDF have been designed according to this way of thinking.

As a matter of fact, there is a deep-buried lock in programmers and theoreticians' minds. This mental lock prevents them to find a better way to represent knowledge. It can be explained by the fact the _box_ approach is a natural transposition of "writing", an aged technology which consists in putting signs at expected locations on some adequate support. In other means, this design principle is what human beings are accustomed to.

The fact is that this natural approach is inherently limited because it only makes computer able to work on a given value in a given box but not on "that value in that box" relation itself. Indeed, the particular "that value in that given box" piece of information can't directly be used neither as a box nor a value.

In other words, it's the _box_ way which dooms abstraction and expressiveness of computers' knowledge and makes them inherently stupid.

The EntrelacsSystem proposal consists in reinventing data computing from scratch and getting ride of this weak "value in a box" way of thinking. This proposal consists in representing knowledge through a single building block: the _arrow_.

===what's an arrow?===

In short, an arrow is... a pair of arrows.

* C coders may see it as a structure of 2 pointers both referring such a structure.
* Lisp coders as a _con_.
* SQL hackers as a record in a twice reentrant relation table.
* REST developers as a pair of URI being itself identified by an URI.

Note how the arrow twice recursive definition is self-sufficient. One of its feature is homoiconicity, meaning that contrary to many academic models, arrows theory doesn't depend on a concept duality like _vertices and edge_.

That's why arrows structure are so different than graphs seen in academic institutions. Please forget everything you learned as it won't fit well. As an example, according to language theory, arrows set should be studied as a formal grammar with no terminal symbols, which is obviously out of the theory scope.

==
I'm convinced arrows are the only one building block I need to store any kind of information. How it could be?

Let's me introduce first you what I call "entrelacs".

"Entrelacs" are intricate balls of arrows linked each others. For example, the single arrow which refers itself both by its tail and its head forms an entrelacs by itself.

Please keep in mind this particular arrow. Further in the reading, I'll call it "Eve". By now, I postulate there is only one "Eve" arrow. Think about it as a pure mathematical object recognizable by this particular topology: eve.tail = eve.head = eve.

Entrelacs are very important. You can isolate them, recognize them, order them, enumerate them... As a matter of fact, entrelacs perfectly act as terms.

So one can build arrows out of terms like the "Hello" character string even if one only deals with arrows. Do you get the point? Terms are actually equivalent to much or less complex entrelacs, that is arrows. "Hello" is an arrow, "world" is another one. Everything is arrow. So one can consider arrows linking terms, like the arrow between "Hello" and "World" strings. Such arrows can be linked in turn by some other arrows, and so on.

At this step, we've got "signs" -thanks to entrelacs- and arrows to combine these signs in expressive structures. But signs are useless without a meaning. Hopefully, you can define a dictionary out of entrelacs. For example, you may decide that "Eve" (formerly introduced) corresponds to the zero digit. Then you may define a programming language based on this assumption.

However here is a major difference with traditional systems. With the "value in a box" paradigm, Meaning is most of the time "hard-coded". In other words, it lays out of the scope of the system.

On the other side, arrows based knowledge representation allows meaning to be defined according to a context that will be expressed by arrows as well. Those arrows can in turn get a meaning from an upper context. And so on.

Now, let's speak about the "PI" number. Are you agree how your brain can easily make an abstraction out of "PI" and elaborate out of it? On its own, a computer stores plenty of copies of the same PI values and symbols, and yet it can't handle "PI" as is, that is as a pure concept. It can't take decisions about it, access the knowledge it's got about it, know when it uses it, and such.

But arrows based computing does, because the second point of the definition of the arrow is that each arrow is uniquely defined both mathematically and within the system storage space. For example, the arrow linking "hello" to "world" is unique. It is also stored only once in the whole system memory.

The point is not so much to spare storage resources. The point is that now the system CAN access any information related to, says, "hello" and "world" strings linked together. It can interact with other systems and human beings about this "hello" and "world" arrow. It can handle it, found all the meanings of it, and elaborate on it as a concept, juste like the human brain always does.

Now you may ask: how can I could host several applications within such a system if they all shares the same arrows?

This is the third and last point of what an arrow is. Arrows are immutable. Once an arrow is stored within the system, you can't change it. So no risk of side effects.

Arrows structures are consequently persistent. When the end user interacts with the system, it doesn't modify these structures in place, it only create new structures by reusing most parts of the existing material. File system authors call this principle "copy on write", but this expression doesn't fit well, because one never copies anything, and one writes a given arrow only once.

Now you might share some doubts about the overall system efficiency. You're right worring. Ensuring each arrow is stored only once is costly. It has to be checked in two cases.
 * When one imports some data from the outside.
 * When some internal process declares new arrows within the system.

The EntrelacsSystem proposal consists in transforming the whole computer storage space into a giant self-refered open-adressed hash table. For each considered arrow, one computes an hash from its definition and looks for an existing copy into memory at the hash-given location. If such a copy exists, one reuses it, otherelse one stores the arrow there. One store arrows in a constructive way. One first builds terms, then term pairs, then more complex arrows, and so on. Actually, it's quite simple, isn't it?

That being said, please note the EntrelacsSystem also features orthogonal persistency and garbage collecting. These buzzwords mean that the system totally blurs the old computing space boundaries (you know... RAM, disk, files...) by offering a much more convenient and consistent working space where every agent is alive and every piece of information is saved on the fly. The nice part of it is that arrows based storage makes these properties really easy to design.

It's time to put the stress on what the system knowledge looks like as a whole. As a matter of facts, the whole system knowledge might be seen as a single giant structure of arrows totally contained in a single unique arrow definition. You read well: the whole knowledge of the system at a given actually consists in only one arrow whose all the ancestors form the knowledge as a whole.

However this theoretical view is not very handy. A simpler solution consists in adding a boolean flag to each arrow definition, telling whether the arrow belongs to a root context or not. This flag is the only modifiable property within the arrow definition. When set, the arrow and all its ancestors are stored into disk and are spared from the garbage collector process. When unset, the corresponding arrow is recycled as soon as no other arrow refers it any more (reference counters are used on this purpose).

I guess at this step of this reading, you might still wonder what kind of programming language the EntrelacsSystem corresponds to.

As a matter of fact, one can adapt any existing language to handle arrow structures. It may be some sort of imperative or declarative language. It may be functional, procedural or object oriented as well.

Please note as well that many abstract machines, corresponding to many languages and modeling technologies, could be hosted within a single system. Arrows allow to embed evaluation contexts each others in a very natural way. As a matter of facts, creating Domain Specific Languages could be probably the best way to add knowledge into a working system. In other words, each application -even your favorite office application- might be viewed as a abstract machine processing inputs and computing outputs according to a particular language. This machine could be defined on a top of a virtual running machine, which could be in turn defined on top of a meta machine, and so on.

However the root context of evaluation still needs for a primary language. How could it looks like? Lambda Calculus, Combinatory Logic?

The point is that the arrows underlying theory deals with information representation, while lambda calculus, combinatory logic or pattern matching are fundamental theories of computation.


Language theoreticians somewhat ignore the information representation part of the overall problem. That's why they often look a little bit condescending regarding real world trends like object-oriented technologies or tagsonomies. On my own, I see these trends as incomplete attempts to enhance the representation problem. A good language and its related runtime environment should combine the best of these two worlds.

That being said, I think the EntrelacsSystem is a basis to invent a new language from scratch. Such a language could leverage on arrows based storage to get innovative properties like:
 * making all internal aspects of the language first order objects: closures, continuations, partial evaluations, environments, continuation chains...
 * generalizing "memoization": that is offering a transparent computation cache for any intermediate and complete computations so to never repeat twice the same calculation.

That's why I prefer to introduce the EntrelacsSystem as a new kind of computing environment rather than yet another data base manager. If you read me carefully, I think you may understand this point of view now.

Please contact me if you'd like to contribute to this project. To be honest, I've no spare time for it at the moment being. I forecast I won't be able to work much on it during these next years.

And yet, I do think one could design an arrows space prototype right now. On a more theoretical side, one still needs a convenient language as a primary abstract machine. I'm currently exploring how I could adapt a CaEK machine to make it arrows oriented. If anybody out there finds this idea exciting, I'd be happy pass on the torch.