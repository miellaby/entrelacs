#summary Entrelacs Prototype architecture.

Entrelacs might eventually become a real Operating System. But for the moment, the Entrelacs prototype stands as yet an other virtual machine on top of an existing software stack; typically a GNU/Linux system.

Entrelacs prototype includes several nested components:
  * An [EntrelacsServer HTTP/REST server].
  * The [EntrelacsAbstractMachine Entrelacs machine].
  * The [ArrowsSpace Arrows Space]. 

There are two public interfaces which gives access to both the ArrowsSpace and the EntrelacsAbstractMachine.
  * The C API of the [EntrelacsLibrary entrelacs library]
  * The HTTP/REST network API of the [EntrelacsServer].

In addition, a future API should permit the addition of native code to the Entrelacs machine. This API might been comprehended by the Entrelacs System itself, so rooting a particular arrow including a binary executable as a Blob might assimilate this binary as a system extension.

== Architecture of Entrelacs powered environments == 

This chapter introduces the different roles of _agents_ which may interact with the EntrelacsSystem.

=== external, internal, or both ===

One can distinguish _external_ and _internal_ agents.
  * internal agents run within the system. Behavior is produced by evaluating [EntrelacsLanguage EL code] within the [EntrelacsAbstractMachine Entrelacs Machine].
  * external agents are pieces of software/hardware out of the EntrelacsSystem boundaries. They may run next to the EntrelacsServer on the same hosting platform, or be located on a remote platform.

However, most external agents are also internal as they also register system-side EL code to perform a part of their behavior.

Note: External agents are not subject to system reflexivity, in the same way an human brain can not deeply change other human organs.

=== Arrows publishers, subscribers, evaluators ===

The architecture suggests the following classification of agents.
  * "evaluators",
  * "publishers",
  * "subscribers".

An evaluator is an agent which defines a public function that other agents may invoke. The agent is called back when the function is applied. It may access and modify the current machine state and/or more basically return a result.

Publishers and subscribers make use of the "publish" and "subscribe" native functions which implements a publish/subscribe messaging bus.

  * A _Publisher_ converts events into arrows and "submit" them to the bus.
    * External publishers may assimilate user actions, hardware events, etc.
    * Internal publishers may produce new arrows in response to previously bus-submitted arrows.
  * A _Subscriber_ registers _closures_ which are applied to arrows submitted on the bus. One may subscribe to a subset of bus-submitted arrows thanks to a pattern matching mechanism.
     * An external subscriber agent may typically convert back _output arrows_ into comprehensible output or behavior: network messages, graphical/textual feedback, hardware actions, etc.
     * An internal subscriber may produce system behavior in response to _input arrows_.

Note the combination of an external publisher and subscriber may form a complete "proxy agent", that is an agent which may act as a representative of a human or digital user. An end-user terminal or any other communication channel should be designed as a proxy agent.

=== Sequence ===

The Entrelacs overall interaction loop is the following.
  * an external event occurs.
  * A publisher processes this event, assimilates relevant data as an arrow, and submit it to the Entrelacs powered bus.
  * The event arrow is applied to matching subscriber closures. The application is evaluated by the prim engine. The evaluation may induce:
     * persistent changes in the system knowledge,
     * various effects due to "arrow evaluators",
     * newly published arrows.
  * Some published arrows are converted back into system output by one or several external subscribers.

Note: Most of this process is powered by the Entrelacs prim engine which performs transparent memoization.