#summary Scratch Page. Work in progress.

= Introduction =
This a *scratch page* to store work in progress note and ideas.
*Last additions are listed first.*

= VM scope =
I think I may be more precise about the scope of the Entrelacs VM.
  * No, for now the Entrelacs language doesn't pretend to replace every other existing languages.
  * No, for now the Entrelacs Virtual Machine doesn't pretend to hold up higher levels language as the .NET machine does for C# and VB.

The main goal of the Entrelacs machine is to evaluate composition of Entrelacs Space primitive operators (these operators will be evaluated in a continuation passing style way).

In other means, the scope of this machine is equivalent to the scope of an SQL engine in a relationnal data base.

So, the Entrelacs machine is here to be used by old-school program (typically built from compiled C sources) which wants to query the Arrows Space in the simplest way. Such executables would be probably stored among the arrow graph, even if they are powered by the system VM. Programs to be evaluated by EVM might be build by the caller on the fly or be persistently stored inside the graph.

However, the future of this project might be to enhance the EVM in order to transform it in a full-featured virtual machine with an efficient optimization and machine-code generation mechanism.


= Future usage =
== prototype as a web server usage ideas ==
   * powering a mind-mapping web application based on arrows rather than old-school graphs.
   * sharing files and actually anything else between its web users.
   * powering various AJAX&COMET application.
== arrows made structures ideas ==
   * mute arrows in fundamental modeled neurons. Each neuron-arrow might be enriched with a learning coefficient evolving according to Hebb's rule.
   * TO DO: porting _Hebb's rule_ to arrows graph.

= Entrelacs vs. X theory =

=== vs. Shanon ===
   * Entrelacs doesn't pretend to encode data further than any limit proved by http://en.wikipedia.org/wiki/Information_theory
   * However, by adapting Huffman coding to transform a sequence of atoms into a structure of unique pairs, it should be possible to optimize the way to pair things (that is in a way which makes the resulting graph more compact)

=== vs. Turing ===
   * Entrelacs doesn't pretend to do things which couldn't be accomplished by any other computing languages and run-time environments as we already know everything is eventually equivalent to a Turing Machine, not less nor more.
   * However, two Turing equivalent systems can be very different in terms of usability and utility. You might write a Word Processor with the famous Conway "Game Of Life" Automata, but it's much more efficient to use a modern computing language which surpasses its concurrents in expressiveness like OCAML does.
   * Entrelacs system surpasses classical system in information handling. When data are stored in Entrelacs, they are much more useful than when they are stored in a classical file read by a classical application over a classical operating system. That's all the reason why this project exists.

= ideas=
==Not yet dead ideas ==
   * move INGOIN/OUTGOING cells to stuff holes due to cells deletion.

== definitely dead ideas ==

This ยง gathers dismissed quite stupid ideas

   * ~use the arrow reference counter to reduce the search range of IN/OUT arrows. The reference counters may be duplicated (one for IN, one for OUT) on this purpose.
   * combine a "lastOne" bit with cell contents to limit a little more open addressing search. This bit must be updated when adding or removing elements in a block.

= I daren't =
   * I daren't thinking this "information brought by an entrelacs machine" idea is the most important invention since writing.