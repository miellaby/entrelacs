#summary Scratch Page. Work in progress.

= Introduction =
This a *scratch page* to store work in progress, notes and ideas.
*Last additions are listed first.*

= About VM API for executable hook =
This section deals with an API to be used by software linked with an autonomous entrelacs system as a library.
  * it is quite the same thing than an exe linked with sqlite
  * the exe builds arrows by calling tag() and blob() functions and combining their results with arrow() calls.
  * the exe may build an EVM (Entrelacs VM) program in the same way because EVM programs source code are made from arrows.
 * reserved arrows of the EL (Entrelac Languages) might be retrieved by corresponding functions, like h() (not to confound with the head function of the C API). 
  * it could also be possible to quickly retrieve an arrow defined by a DNP (dot and parenthesis) string.
     * a DNP string defines an arrow as a structure of pairs of strings. It follows a simple language which recycles popular operators from various classical languages.
  * a function working like printf() might be used to operate DNP strings including run-time parameters. Parameter values would be given at function call. In other means, the DNP string corresponds to the printf() format string and the dynamical parameters corresponds additional function arguments.
  * an operator similar with tag() and blob(), namely hook(), would allow to build a _continuation_ from a function pointer.
    * like the lambda operator, the hook() call might build a continuation based on the current environment.
  * I wish to extend the hook concept to the network oriented prototype. The callback might be proceed trough some sort of RPC technology.

= VM scope =
I think I may be more precise about the scope of the Entrelacs VM.
  * No, for now the Entrelacs language doesn't pretend to replace every other existing languages.
  * No, for now the Entrelacs Virtual Machine doesn't pretend to hold up higher levels language as the .NET machine does for C# and VB.

The main goal of the Entrelacs machine is to evaluate composition of Entrelacs Space primitive operators (these operators will be evaluated in a continuation passing style way).

In other means, the scope of this machine is equivalent to the scope of an SQL engine in a relationnal data base.

So, the Entrelacs machine is here to be used by old-school program (typically built from compiled C sources) which wants to query the Arrows Space in the simplest way. Such executables would be probably stored among the arrow graph, even if they are powered by the system VM. Programs to be evaluated by EVM might be build by the caller on the fly or be persistently stored inside the graph.

However, the future of this project might be to enhance the EVM in order to transform it in a full-featured virtual machine with an efficient optimization and machine-code generation mechanism.


= Future usage =
== prototype as a web server usage ideas ==
   * powering a mind-mapping web application based on arrows rather than old-school graphs.
   * sharing files and actually anything else between its web users.
   * powering various AJAX&COMET application.
== arrows made structures ideas ==
   * mute arrows in fundamental modeled neurons. Each neuron-arrow might be enriched with a learning coefficient evolving according to Hebb's rule.
   * TO DO: porting _Hebb's rule_ to arrows graph.

= Entrelacs vs. X theory =

=== vs. Shanon ===
   * Entrelacs doesn't pretend to encode data further than any limit proved by http://en.wikipedia.org/wiki/Information_theory
   * However, by adapting Huffman coding to transform a sequence of atoms into a structure of unique pairs, it should be possible to optimize the way to pair things (that is in a way which makes the resulting graph more compact)

=== vs. Turing ===
   * Entrelacs doesn't pretend to do things which couldn't be accomplished by any other computing languages and run-time environments as we already know everything is eventually equivalent to a Turing Machine, not less nor more.
   * However, two Turing equivalent systems can be very different in terms of usability and utility. You might write a Word Processor with the famous Conway "Game Of Life" Automata, but it's much more efficient to use a modern computing language which surpasses its concurrents in expressiveness like OCAML does.
   * Entrelacs system surpasses classical system in information handling. When data are stored in Entrelacs, they are much more useful than when they are stored in a classical file read by a classical application over a classical operating system. That's all the reason why this project exists.

= ideas=
==Not yet dead ideas ==
   * move INGOIN/OUTGOING cells to stuff holes due to cells deletion.

== definitely dead ideas ==

This ยง gathers dismissed quite stupid ideas

   * ~use the arrow reference counter to reduce the search range of IN/OUT arrows. The reference counters may be duplicated (one for IN, one for OUT) on this purpose.
   * combine a "lastOne" bit with cell contents to limit a little more open addressing search. This bit must be updated when adding or removing elements in a block.

= I daren't =
   * I daren't thinking this "information brought by an entrelacs machine" idea is the most important invention since writing.