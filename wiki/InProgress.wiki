#summary Scratch Page. Work in progress.

= Introduction =
This a *scratch page* to store work in progress, notes and ideas.
*Last additions are listed first.*

= About VM API for executable hook =
This section deals with an API to be used by software linked with a running entrelacs system (ES) prototype.

How to imagine this binary software linked with ES?

1st approach: the ES is a library. The resulting executable embeds an autonomous ES.
  * it is quite the same thing than an exe linked with sqlite
  * I don't want that. I want a single ES by host.

2d approach: Executables are binary extensions loaded by a single shared entrelacs server, i.e plugins.
  * plugins could be loaded when put in a dedicated folder of a running ES installation, supposing they are dynamical libraries.
  * once the dynamic library is loaded, an onLoad() function might be resolved then called. This function would register "hooks" into the system, that is arrows bound to pointer-to-function based continuations.
   * those bounded arrows might be compared with executable files put in a filesystem.

3d approach: Executables pushed into the network API
   * I suppose such extensions should also be added via the main API, that is the network HTTP based API. The extensions data might be sent through some POST DATA.
   * a better way to hook a binary program might be to send the program body including a well defined entry point (corresponding to the hook) thanks to a special operator which might bind this exe to a given arrow.

Reminder
   * A HTTP agent communicating with ES should immediatly be assigned with a session cookie. Communication must occure in sessions. A non trusted client would be confined in a sub-context of the system. It means such a client would have no access to the root context. It'd be confined inside a sort of embedded context. The operation might be transparent to the agent who could not guess whether it hits the root context or a sort of virtual instance of entrelacs. It might be comparable with an operating system running inside a virtualized host.
   * On the other side, a trusted agent might access to a upper context where risky operations are really proceeded. The administrator agent might directly handle the system root context.
   * A simple way to design embedded entrelacs context might be to transform every root()/unroot() so that the actually rooted/unrooted arrow won't be the agent one but a composed arrow linking the initial arrow with a context identifier arrow.


Reflexion: REST philosophy supports Entrelacs theory
   * REST meta design pattern recommends to model an application as a set of named resources with well-defined identifier (URI).
   * ES approach leads to name everything as everything is eventually an arrow and that each arrow has an unique and permanent ID.


About the C API
  * the exe builds arrows by calling tag() and blob() functions and combining their results with arrow() calls.
  * those are functions out of some sort of C API
{{{
 ArrowRef tag(char *);
 ArrowRef blob(char *, uint64 length);
 ArrowRef blobFromFile(char *path);
 ArrowRef arrow(ArrowRef head, ArrowRef queue);
}}}

  * the exe may build an EVM (Entrelacs VM) program in the same way because EL source code are made from arrows.
    * reserved arrows of the EL (Entrelac Language) might be retrieved by their corresponding functions in the C API. Don't confuse h() (returning the h operator of the EL language) with head() (returning the head of a given arrow). 

  * it could also be possible to quickly retrieve an arrow defined by a DNP (dot and parenthesis) string.
     * a DNP string defines an arrow as a structure of pairs of strings. It follows a simple language which recycles popular operators from various classical languages.
     * a function working like printf() might be used to operate DNP strings including run-time parameters. Parameter values would be given at function call. In other means, the DNP string would correspond to the printf() format string and the run-time parameters would correspond to the remaining arguments.
{{{
   #include <stdarg.h>
   ArrowRef arrowFromDNP(char* DNP, ...);

   [...]
   ArrowRef demo = arrowFromDNP("(a.?)->b", someString);
}}}

  * once a EVM program built, one might evaluate it through the exec function()
  * an operator similar with tag() and blob(), namely hook(), would allow to build a _continuation_ from a function pointer.
    * like the lambda operator, the hook() would build a continuation based on the current environment.

I have to extend this API to the network oriented prototype.
     * The arrowFromDNP call might send the resulting DNP string to the Entrelacs server and receive back an arrow ID.
     * The hook function might be proceed trough some sort of RPC technology.
     * The exec() function would consist in putting the to-be-run arrow id into the input queue.

Concept list: EL, EVM, EVM program, EL source, DNP, DNP printf, blob()


= VM scope =
I think I may be more precise about the scope of the Entrelacs VM.
  * No, for now the Entrelacs language doesn't pretend to replace every other existing languages.
  * No, for now the Entrelacs Virtual Machine doesn't pretend to hold up higher levels language as the .NET machine does for C# and VB.

The main goal of the Entrelacs machine is to evaluate composition of Entrelacs Space primitive operators (these operators will be evaluated in a continuation passing style way).

In other means, the scope of this machine is equivalent to the scope of an SQL engine in a relationnal data base.

So, the Entrelacs machine is here to be used by old-school program (typically built from compiled C sources) which wants to query the Arrows Space in the simplest way. Such executables would be probably stored among the arrow graph, even if they are powered by the system VM. Programs to be evaluated by EVM might be build by the caller on the fly or be persistently stored inside the graph.

However, the future of this project might be to enhance the EVM in order to transform it in a full-featured virtual machine with an efficient optimization and machine-code generation mechanism.


= Future usage =
== prototype as a web server usage ideas ==
   * powering a mind-mapping web application based on arrows rather than old-school graphs.
   * sharing files and actually anything else between its web users.
   * powering various AJAX&COMET application.
== arrows made structures ideas ==
   * mute arrows in fundamental modeled neurons. Each neuron-arrow might be enriched with a learning coefficient evolving according to Hebb's rule.
   * TO DO: porting _Hebb's rule_ to arrows graph.

= Entrelacs vs. X theory =

=== vs. Shanon ===
   * Entrelacs doesn't pretend to encode data further than any limit proved by http://en.wikipedia.org/wiki/Information_theory
   * However, by adapting Huffman coding to transform a sequence of atoms into a structure of unique pairs, it should be possible to optimize the way to pair things (that is in a way which makes the resulting graph more compact)

=== vs. Turing ===
   * Entrelacs doesn't pretend to do things which couldn't be accomplished by any other computing languages and run-time environments as we already know everything is eventually equivalent to a Turing Machine, not less nor more.
   * However, two Turing equivalent systems can be very different in terms of usability and utility. You might write a Word Processor with the famous Conway "Game Of Life" Automata, but it's much more efficient to use a modern computing language which surpasses its concurrents in expressiveness like OCAML does.
   * Entrelacs system surpasses classical system in information handling. When data are stored in Entrelacs, they are much more useful than when they are stored in a classical file read by a classical application over a classical operating system. That's all the reason why this project exists.

= ideas=
==Not yet dead ideas ==
   * move INGOIN/OUTGOING cells to stuff holes due to cells deletion.

== definitely dead ideas ==

This ยง gathers dismissed quite stupid ideas

   * ~use the arrow reference counter to reduce the search range of IN/OUT arrows. The reference counters may be duplicated (one for IN, one for OUT) on this purpose.
   * combine a "lastOne" bit with cell contents to limit a little more open addressing search. This bit must be updated when adding or removing elements in a block.

= I daren't =
   * I daren't thinking this "information brought by an entrelacs machine" idea is the most important invention since writing.