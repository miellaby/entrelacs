#summary Introduction to the Entrelacs Virtual Machine.

==system iteration and interaction loop==

The prim engine which empowers an _Entrelacs_ system looks like a Lisp machine running the overall system interaction loop, Something like :
{{{
   repeat forever:
     read one input arrow
     compute {behavior := behavior(input)} ; with side effects
}}}

This interaction loop reads received arrows one by one and applies the system behavior function to them. This running cycle is called a "_system iteration_".

Note each iteration is confined into a "arrows space transaction" so that Entrelacs iterates between stable persistent states.

==rooted arrows==

This system behavior function actually correspond to the _root context_ of the system. This context is formed by flagged arrows among the arrows space, namely the "_rooted arrows_".

== arrow pattern matching and rewriting rules==

Rooted arrows may be seen as pattern based rewriting rules. These rules defines how patterns of arrows lead to generate some other arrows.

==arrows combinatory logic==

Actually, Entrelacs rewriting rules are recombination rules. It means they are build with *combinators*, that is operators which don't relay on "_variables_".

As is, "Lambda barre" language is nearest from "combinatory logic" theoretical language  than "lambda calculus"
   * See http://en.wikipedia.org/wiki/Combinatory_logic.
   * See EntrelacsLanguage for details.

==Universal cache==
Entrelacs Virtual Machine operates the ArrowsSpace as an universal cache. In other means, incoming arrows or arrows produced while computing may be cached in the ArrowSpace. Cache recovery may dramatically improve communication and computing. This mechanism works both as a data cache (see http://en.wikipedia.org/wiki/Cache) and a computation cache (see http://en.wikipedia.org/wiki/Memoization). Work in progress.