# Introduction #

The ArrowParadigm encompasses commonly used information representation solutions like semantic planar graphs, relational data bases, and frame-based (like object oriented) models. It brings to Entrelacs Systems a lot of unique abilities no operating system / computing environment has ever shown before.

# Entrelacs _"full abilities"_ #

  * _full homoiconicity_ : By getting rid of the "value in a box" way of thinking, Entrelacs Systems free themselves from many imposed _dualities_ which curb existing data computing engineering. To name a few: "edge vs. node", "program vs. data", "entity vs. relation", "fact vs. rule", "variable vs. value", "user vs. programmer", "function vs. object", and so on.

  * _full relationism_ : Relations are first order and are actually only citizens within the system. Even atomic data are seen as discrete closed structures of relations (namely _entrelacs_).

  * _full scale invariance_ (in both complexity and abstraction scales): Within Entrelacs, and whatever its complexity or abstraction level, a piece of information always consists in a structure of arrows featuring a consistent set of properties and operators. A character string, a full featured office suite, a meta-model definition, an "hello world" code: **all of them are arrows constructs**.

  * _full relativity_ : At any time, any piece information can be used in an upper context as either a thing to be "tagged"/"refered" or a "tag"/"reference". Resulting tagged-to-tag relations can be abstracted in turn. There is no limit to how subtle and deep statments can be made.

  * _full reflexivity_ : Thoses unique Entrelacs' properties give to hosted agents the ability to elaborate about knowledge (and behavior) like a human being usually does, that is by conducing _introspection_ and _intercession_ activities. Programs are both accessible and modifiable at the highest level (source code) and in a persistent way.

  * _fully free of redundancy_ : An Entrelacs system ensures there is never more than one copy of each definable arrow in the whole information space. This copy is managed as the mapping of the pure mathematical object it represents.

  * _full indexation_ : The system allows to efficiently retrieve the _connectivity_ of a given arrow, that is whose arrows are linked to this arrow. As the system is redundancy free, it implies each piece of information forms an index to all its related information within the whole system.

  * _full orthogonal, incremental, and fined-grained persistence_ : The system handles structured knowledge at the finest granularity possible. This property makes _incremental and orthogonal persistence_ a native system feature. It means neither the application developer nor the end user needs to care of data saving. The whole machine state and knowledge is preserved from power outage in a transparent (no human guidance), continuous and seamless way.

  * _full immutability_ : As arrows are immutable, structures of arrows are naturally _persistent data structures_. The system never writes over existing information as long as it hasn't been forgotten. Whatever the job to be done, the system can be asked to elaborate on past data and roll back to its previous state.

  * _full seamless garbage collection_ : The system automatically retrieves resources used by dismissed knowledge. No human guidance is required because arrows made this process simple.

  * _full memoization_ : Arrows make it easy to design systems which memorize and get back intermediate or final computation results. It leads to a kind of system level _memoization_. Think of it as an universal cache of all computed results which prevents the system to repeat the same work twice.

  * _full virtualization_ (abstraction of anything) : Even in regular systems, one may note that code evaluation takes place on top of a stack of abstract machines starting from a root computing environment. But Entrelacs systems make it easy to handle and change this combination of abstract machines so to produce new behavior from existing code. Entrelacs systems allow new forms of code reuse.

  * _full upward security_ (simulate anything) : Arrows make it easy to put any doubtful agent (software or user) into an hosted fake system without the agent knowing it.

# Some related concepts and technologies #

  * The ArrowParadigm
  * http://en.wikipedia.org/wiki/Reflection_(computer_science)
  * http://en.wikipedia.org/wiki/Homoiconicity
  * http://en.wikipedia.org/wiki/Orthogonal_persistence
  * http://en.wikipedia.org/wiki/Purely_functional
  * http://en.wikipedia.org/wiki/Persistent_data_structure
  * http://en.wikipedia.org/wiki/Scale_invariance
  * http://en.wikipedia.org/wiki/Memoization

# Some opposed or superseded concepts #

  * First of all, please note **[arrow structures are NOT graphs](http://en.wikipedia.org/wiki/Glossary_of_graph_theory)**.
  * http://en.wikipedia.org/wiki/File_system
  * http://en.wikipedia.org/wiki/Object_database
  * http://en.wikipedia.org/wiki/Navigational_Database
  * http://en.wikipedia.org/wiki/Relational_database
  * http://en.wikipedia.org/wiki/Relational_model
  * http://en.wikipedia.org/wiki/Graph_database
  * http://en.wikipedia.org/wiki/Operating_system (regular model)
  * http://en.wikipedia.org/wiki/NoSQL
  * http://en.wikipedia.org/wiki/Tag_(metadata)
  * http://en.wikipedia.org/wiki/Semantic_Web
  * http://en.wikipedia.org/wiki/Resource_Description_Framework