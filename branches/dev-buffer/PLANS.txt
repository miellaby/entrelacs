Current change: Arrow buffer
 * currently via a dedicated API
   * arrow buffer API: buffer.c/h
   * Same operators than the space API: buffer_* <=> xl_*
   * might become the default implem (xl_* API)
 * It's a RAM-based buffer for arrows. Put in front of the arrows space
 * mainly used by the EL machine for quick disk-free arrow manipulation
 * arrows are autonomously managed in the buffer, whatever their server counterparts.
 * they got buffer-specific addresses ( and id ).
 * buffer implementation depends on ram.c/h: volatile memory as a bank of of 0x100000 cells
 * buffer specific 28 bytes memory model for "cells"
   * each buffered arrow definition includes "spaceId"
   * spaceId identifies the corresponding arrow in the arrows space.
   * spaceId != bufferedArrow.id
 * By default, arrows assimilated via the buffer API are not bound to their spatial counterparts.
   * For exemple, spaceId initialy = NULL for the arrow assimilated by buffer_atom("toto")
 * one "resolves"  a buffered arrow (bind it to its server counterpart) on demand. That is,
   * at first call of buffer_isRooted()
   * or at first call of buffer_childrenOf()
 * spaceId is set to NIL if no disk counterpart is found when resolving a buffered arrow
 * one "pulls" the server-side children list of an arrow at the firt call of buffer_childrenOf()
 * children parents are lazy loaded
 * In the buffer bank, new cell types : PLACEHOLDER; INCOMING_PLACEHOLDER; OUTGOING_...
 * Placeholders stand for pairs which are partialy loaded.
   * One or both ends are only known by a space Id.
 * Placeholders are created for every unknown pair pulled from space
   * typically when retrieving the spatial children list
   * or browsing the ancestors or retrieved arrows.
 * 1st call to buffer_children retrieve the server children list (xl_children)
   Subsequent calls compare the children list revision between buffer and server. 
   If different revisions, fetch again the server list.
   the children iterator not being atomic, one may have new children fetched before
   the iterator ended. It's important to store the children revision number before iterating
 * when pulling a server children list, one call "pull(spaceId)" for each retrieved arrow 
 * when spaceId = NIL (eg uuid), all buffered descendants have automaticaly
   NIL serverId : great optimization, avoid useless xl_children/xl_isRooted
 * on commit root-settted arrows are server-rooted, root-unsetted arrows are server-unrooted
   * so: change flags and changelog
 * buffer can be reserved/freed as a whole
 * buffer is zeroed after usage. TBC.
    * if the buffer is not zeroed,
       * one adds a stamp to every fetched arrow
       * bufferRevision++ at each new buffer session
       * stamp=bufferRevision for every new buffer arrow or otherwise touched arrows
       * when probing an arrow, one saves (in addition of the first free cell) the
         first cell which contains an arrows so than stamp <modulo bufferRevision - 5
       * when putting a new arrow in buffer, one preferes firstOldCell rather than firstFreeCell.
         * if firstOldCell, one deletes firstOldCell, problem: children are too be 
           deleted to, or converted into "placeholders"
 * buffer_sync: ~~resolve + fetch~~ reset server root flag and children list for one arrow/every arrow =~ empty cache / force cache refresh
 * blob in separate directories (/var/tmp)
 * blob are lazy loaded
 * space children retrieval algorithm if based on a buffer_pull() fonction
 * pulling = loading a space arrow known by its spaceId into the buffer
 * buffer_pull(spaceId) =
   * read hash=xl_hashOf(spaceId)
   * look for hash-indexed arrows in the buffer bank
   * if the hash matches to local unresolved arrows,
   * resolve these local arrow(s) first,
   * so to compare the spaceId and avoid duping with local copies,
   * if no local copy then eventually retrieve the pulled arrow definition
   * if the arrow is a pair,
     * create a placeholder containing a spaceId as one of its ends.
     * Outgoing placeholders got buffer Id for tail and space Id for heads 
     * Incoming placeholders got buffer Id for heads, space Id for tails
   * if the arrow is a small/tag atom, retrieve its full definition
   * if the space arrow is a blob, only retrieve its footprint,
   * raw data is pulled on buffer on demand
   * buffer_tailOf (resp. buffer_headOf) will convert a placeholder into a regular pair
      * if cell.arrow.type == OUTGOING_PLACEHOLDER || ...PLACEHOLDER
      * cell.arrow.tailId  = buffer_pull(cell.arrow.tailId)
      * if ...PLACEHOLDER { cell.arrow.headId = .... }
      * cell.arrow.type = PAIR
   * when assimlating a buffered pair, one probes for an existing singleton as usual,
   * but ...
     * if the buffered pair spaceId is not nil (happens if one end is nil)
     * and if one finds a checksum-matching placeholder pair while probing,
     * then one resolves the bufferer pair (call spaceId = xl_pair(buffer_resolve(tail), buffer_resolve(head))
     * if both spaceId match, its a probing hit 

Previous changes:
 * new 24 bytes model
   * new atom type: SMALL
   * new kind of rooting : "weak" rooting
    -  a weak arrow doesn't prevent its both ends GCing
    -  a weak arrow is GCed when its both ends are GCed
    -  an arrow may be independantly strongly rooted and weakly rooted
    -  2 separate boolean root flags per arrow: strong and weak
    -  not yet completed
   * a public hashcode stored in every arrow definition,
   * xl_hashOf() to get the hash of an arrow

 * web terminal (sexy demo)
 * xl_yield(arrow state) (in replacement of xl_over)
   * sync with all threads then GC
   * but in addition: preserve "state" arrow from GC (temporary root)
   * TBC: maybe timeout for yielding
   * is used between each transition of the machine
 * lowest level operators renamed to reflect their behavior
 * example.xl
 * rlambda (closure can access to itself as "it")
 * anonymous arrow API (avoid it as long as you can!)
 * hook API. Root flag is used to prevent attack proof or invalidate a hook
 * not-blocking childrenOf version:
      * syntax: /let/enum/childReview+a
      * returns a new "dynamic" operator
          * returned operator carries a handler to the enumerator
      * apply the operator to perform next/get on the enumerator
      * /enum+ => 1st children, /enum+ 2d children, etc.
 * API now reentrant. Lock at every sensible access of space.c/mem.c
     * no more global lock in server.c
 * a way to sync commit between concurrent agents
     * xl_begin(), xl_over()/xl_commit()
     * see server.c & testshell.c for usage
 * lock on the persistent file to prevent concurrent clients.
     * avoid mess when running several entrelacsd, testshell or any other libentrelacs clients,
     * temporarly close-unlock file right after commit
     * when relocking, one checks if file mtime changed. If so, nuke RAM cache!
* Added: a digest operator.
* Some web clients refuse to escape '.' character in %2E.
   Radical solution: URI format has changed. Now '/tail+head'
* Public API hides implementation of atoms: blob, tag or btag
  * blob or tag according to data size
* when an application is bound as is, it takes precedence over the corresponding closure evaluation.
  * it's an attempt to merge intensive and extensive definitions, that is function and environment/object.
* operator, closure & paddock: auto escaped and somewhat typed litterals. paddock is for macro.
* xls_get now returns NIL (FFFFFF) when no arrow found
* NIL is a undefined arrow. Different from Eve (0)
* virtualized evaluation (root/get/set are confined in a nested hierarchy of contexts)
* resolve now use xls_get to get "global" variable value
* rooting a pair is not enough any more to make a global bound variable.
  * Use xls_set(EVE,slot,value) instead.
      * will do root((EVE->slot)->value) ; root(EVE->(slot->value)))
* looseStack dumped in reverse order
* new API to get and retrieve "uri" (no more xl_program)
* and much more ...

Future:
 * doxygen integration
 * HTTP push connector
   * use in the demo
 * Web terminal
   * user login & persistent changes
   * link layout (relatively to their ends)
   * parametrable "seed"
 * map/reduce operators
   * do we put them in machine.c or not?
   * what if I moved all non trivial definition like if macro elsewhere?
 * site.sh
   * pkill entrelacsd && echo restart... || echo start...
   * entrelacsd &
   * sleep 5
   * for each line in $(cat site.xl) do
        curl GET $SITE/$line
     done ; # define some functions
   * for each filename in glob site/* do
        cat $filename | curl PUT $SITE/$filename --stdin
     done ; # assimilate demo assets
 * MessageBox
   * new operator box
     a hook to a cond lock
   * new operator observe param=box
     wait for the condition lock during 20s
     then/or
     unroot and return childrenOf box rooted
     and paused machine (see hereafter)
   * new operator trigger
     get/create the box arrow if non existant
     root (box, output)
     trigger condition variable
   * new operator pause
     stop the machine and return as /machine/... (new litteral)
      * resume ... restore machine
      * abort ... free machine

In study:
 * the very first child should be attached to the main arrow definition, as most non-rooted arrow are made to be attached to at least one child.
 * a session is actually a continuation
 * a lazy arrow is when (tailOf arrow) or (headOf arrow) are bounds to closure/operator in environment 
 * xls_set: create less arrows (but also less indexation)
     * e.g set x in a.b.c.d.e would only root /a.b.c.d/e.x if depth = 2
 * when an operator is GC by forget() -if tail(a) == operator (space-level reserved keyword)-
                 then forget do call the operator with special *GC* atom
                     on *GC* argument, operator should test it's really a GC (global variable in_commit TODO)
                     and free anything
 * Web terminal
   * infinite "map" of objects with spatial hashing
      * clients sync with tiles every couple of seconds
   * timeline
   * unused objects out of view may move out of screen after a while
   